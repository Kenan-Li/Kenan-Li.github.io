<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="https://kenan-li.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://kenan-li.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2023-04-26T20:34:33+00:00</updated><id>https://kenan-li.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">Spatial Randomness and Autocorrelation</title><link href="https://kenan-li.github.io/blog/2023/Spatial-Autocorrelation/" rel="alternate" type="text/html" title="Spatial Randomness and Autocorrelation"/><published>2023-04-03T00:00:00+00:00</published><updated>2023-04-03T00:00:00+00:00</updated><id>https://kenan-li.github.io/blog/2023/Spatial-Autocorrelation</id><content type="html" xml:base="https://kenan-li.github.io/blog/2023/Spatial-Autocorrelation/"><![CDATA[<h2 id="background">Background</h2> <p>Spatial randomness and spatial autocorrelation are two concepts related to the distribution of data in space. They describe different aspects of spatial data and have different implications for the analysis of spatial patterns.</p> <h3 id="definitions">Definitions</h3> <p><code class="language-plaintext highlighter-rouge">Spatial randomness</code>: Spatial randomness refers to a situation where the location of events or features in space does not follow any discernible pattern. In other words, the events or features are randomly distributed across the study area, and their locations are not influenced by the locations of other events or features. Complete spatial randomness (CSR) is often used as a null hypothesis in spatial analyses, which assumes that the observed pattern is random and not influenced by any underlying spatial process.</p> <p><code class="language-plaintext highlighter-rouge">Spatial autocorrelation</code>: Spatial autocorrelation refers to the correlation between a variable at one location and the same variable at neighboring locations. It measures the degree to which nearby locations exhibit similar (or dissimilar) values. Positive spatial autocorrelation means that similar values are clustered together, while negative spatial autocorrelation means that dissimilar values are closer together. If there is no spatial autocorrelation, the values are randomly distributed across the study area.</p> <h3 id="differences">Differences</h3> <ul> <li> <p>Spatial randomness pertains to the absence of any discernible pattern in the distribution of events or features in space, while spatial autocorrelation measures the correlation between a variable at one location and the same variable at neighboring locations.</p> </li> <li> <p>Spatial randomness is often used as a null hypothesis in spatial analysis, while spatial autocorrelation is an inherent property of the data that can reveal underlying spatial processes or structures.</p> </li> </ul> <p>In summary, spatial randomness and spatial autocorrelation describe different aspects of spatial data. Spatial randomness relates to the distribution of events or features, while spatial autocorrelation quantifies the degree of similarity between values at nearby locations. These concepts are essential for understanding and analyzing spatial patterns in various types of spatial data.</p> <h3 id="complete-spatial-randomness-csr-measurements">Complete Spatial Randomness (CSR) measurements</h3> <ol> <li> <p><code class="language-plaintext highlighter-rouge">Ripley's K function</code>: The K function is used to assess CSR in point patterns. It calculates the expected number of points within a given distance ‘r’ of an arbitrary point, divided by the overall point density. If the observed K function is close to the theoretical K function under CSR, the point pattern is consistent with spatial randomness.</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">L function</code>: The L function is a derived function from Ripley’s K function, which is used to assess Complete Spatial Randomness (CSR) in point pattern data. The L function is designed to provide a linearized visualization of the K function, making it easier to interpret the results.</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">Nearest Neighbor Distance Distribution function (G function)</code>: The G function is another measure used to assess CSR in point patterns. It estimates the cumulative distribution function of the nearest neighbor distances in a point pattern. If the observed G function is close to the theoretical G function under CSR, the point pattern is consistent with spatial randomness.</p> </li> </ol> <h3 id="spatial-autocorrelation-measurements">Spatial autocorrelation measurements</h3> <ol> <li> <p><code class="language-plaintext highlighter-rouge">Moran's I</code> Moran’s I is a global measure of spatial autocorrelation for continuous or areal data. It measures the correlation between a variable at one location and the same variable at neighboring locations. Moran’s I values range from -1 (negative spatial autocorrelation) to 1 (positive spatial autocorrelation), with values close to 0 indicating no spatial autocorrelation.</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">Geary's C</code>: Geary’s C is another global measure of spatial autocorrelation for continuous or areal data. It is based on the difference between values at neighboring locations. Geary’s C values range from 0 (positive spatial autocorrelation) to 2 (negative spatial autocorrelation), with values close to 1 indicating no spatial autocorrelation.</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">Local Indicators of Spatial Association (LISA)</code>: LISA is a set of local measures of spatial autocorrelation for continuous or areal data. It identifies local clusters of high or low values and spatial outliers. Common LISA statistics include Local Moran’s I, Local Geary’s C, and Local Getis-Ord G*.</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">Semivariogram</code>: The semivariogram is a measure of spatial autocorrelation for continuous data that quantifies the similarity between pairs of data points as a function of the distance between them. It is used to model spatial dependence and is the basis for geostatistical techniques like kriging.</p> </li> </ol> <hr/> <h2 id="examples-of-csr">Examples of CSR</h2> <h3 id="using-k-function-and-l-fuction">Using K Function and L Fuction</h3> <p>The K function is defined by:</p> \[K(r) = λ^{-1} * E[N(r)] \quad\quad (1)\] <p>where λ is the point density (total number of points divided by the study area), E[N(r)] is the expected number of points within distance ‘r’ from an arbitrary point, and r is the distance.</p> <p>When analyzing point patterns to test for CSR, we often assume an underlying Poisson process.The theoretical K function under CSR for a Poisson process is:</p> \[K(r) = \pi * r^2 \quad\quad (2)\] <ul> <li> <p>If the observed K function is close to the theoretical K function (Poisson process), the point pattern is consistent with CSR.</p> </li> <li> <p>If the observed K function lies above the theoretical K function, the point pattern exhibits clustering.</p> </li> <li> <p>If the observed K function lies below the theoretical K function, the point pattern exhibits regularity or dispersion.</p> </li> </ul> <p>By comparing the observed K function with the theoretical K function under the CSR assumption, you can assess whether the spatial distribution of points is consistent with a Poisson process or if there is evidence of clustering or regularity in the data.</p> <p>When working with a sample of data points, the K function will not usually be known, and we will use the Edge-corrected estimation of K function (Ripley’s K function):</p> \[K(r) = \left(1 / λ\right) * \sum_{i=1}^{n}\left[\sum_{j\neq i}(I(||u_i - u_j|| &lt;= r) / w(||u_i - u_j||))\right] \quad\quad (3)\] <p>where:</p> <ul> <li>K(r) is the estimated K function at distance r,</li> <li>λ is the point density (total number of points divided by the study area),</li> <li>n is the total number of points in the point pattern,</li> <li>$u_i$ and $u_j$ are the spatial coordinates of points i and j, respectively,</li> <li>$||u_i - u_j||$ is the Euclidean distance between points i and j,</li> <li>I(·) is an indicator function that equals 1 if the condition inside the brackets is true and 0 otherwise,</li> <li>w(·) is an edge-correction function that accounts for the fact that points near the boundary of the study area have fewer neighbors.</li> </ul> <p>The edge correction function is an essential component of Ripley’s K function estimation. It is needed to account for the boundary effects that arise when analyzing point patterns within a finite study area. Points near the boundary of the study area have fewer neighbors than points located in the interior, which can lead to biased estimations of the K function. Note that there are different edge-correction methods available, such as the isotropic correction, which is the default method in Ripley’s K function estimation. The isotropic correction is given by:</p> \[w(||u_i - u_j||) = 1/(1 - (π * r^2 / A)) \quad\quad (4)\] <p>The L function is derived from the K function and is used to provide a linearized interpretation of the results from the K function. The L function is defined as:</p> \[L(r) = \sqrt{\frac{K(r)}{\pi}} \quad\quad (5)\] <p>Given a Poisson process, we can substitute Equation 2 into the L function to get the L function under CSR:</p> \[L_{CSR}(r) = \sqrt{\frac{\pi r^2}{\pi}} = r \quad\quad (6)\] <p>To simplify the interpretation of the L function, we often plot the difference between the L function and the distance r:</p> \[L(r) - r \quad\quad (7)\] <p>The relationship between the K function and the L function can be summarized as follows:</p> <ul> <li> <p>The L function is derived from the K function to provide a linearized interpretation of the spatial pattern analysis.</p> </li> <li> <p>The L function under CSR is equal to the distance r, which simplifies the interpretation of the results.</p> </li> <li> <p>By plotting the difference between the L function and the distance r, we can easily identify deviations from CSR, clustering, or dispersion.</p> </li> </ul> <p>To interpret the L(r) - r plot:</p> <ul> <li> <p>If the L(r) - r plot is close to the horizontal axis (L(r) - r ≈ 0), it suggests Complete Spatial Randomness (CSR).</p> </li> <li> <p>If the L(r) - r plot lies above the horizontal axis (L(r) - r &gt; 0), it indicates clustering.</p> </li> <li> <p>If the L(r) - r plot lies below the horizontal axis (L(r) - r &lt; 0), it indicates regularity or dispersion.</p> </li> </ul> <p>In summary, the L function is derived from the K function to provide a more straightforward interpretation of spatial patterns in point data. By comparing the L function plot with the expected L function under CSR (L(r) = r), we can assess the degree of clustering or regularity in the data.</p> <p>In the following example, we will use Ripley’s K function to analyze the <code class="language-plaintext highlighter-rouge">bramblecanes</code> dataset from the <code class="language-plaintext highlighter-rouge">spatstat</code>library in R. First, Let us visulize the locations of the bramble canes being analysed.</p> <p><strong>Figure 1: Bramble Cane Locations</strong></p> <div class="row"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/bramblecanes_locations-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/bramblecanes_locations-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/bramblecanes_locations-1400.webp"/> <img src="/assets/img/bramblecanes_locations.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" title="Bramble Cane Locations" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>Next, we will extimate and plot the observed K function along with the theoretical K function under CSR</p> <figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">K_hat</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">Kest</span><span class="p">(</span><span class="n">bramblecanes</span><span class="p">)</span><span class="w">
</span><span class="n">plot</span><span class="p">(</span><span class="n">K_hat</span><span class="p">,</span><span class="w"> </span><span class="n">main</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"Observed K Function vs. Theoretical K Function (CSR)"</span><span class="p">)</span></code></pre></figure> <p>Besides of the isotropic correction mentioned in Equation 4, <code class="language-plaintext highlighter-rouge">Kest</code> by defualt outputs results using the other three edge correction below:</p> <ul> <li> <p>Border correction: The border edge correction method adjusts the K function estimate by taking into account the distance between the points and the study region’s boundary. It assumes that the point pattern’s intensity is constant up to the boundary, and beyond the boundary, it drops to zero. The border method is suitable when the study region’s boundary is irregular or complex. The border method works by applying a correction factor to the K function estimates, which is based on the distance of each point to the nearest point on the boundary.</p> </li> <li> <p>Translation correction: The translate edge correction method adjusts the K function estimate by translating the point pattern to several random locations and averaging the K function estimates obtained from each translation. This method assumes that the point pattern is homogeneous and isotropic, meaning that the intensity and orientation of the point pattern are the same throughout the study region. The translate method is suitable for rectangular or square-shaped study regions with uniform boundaries.</p> </li> <li> <p>Periodic correction: The periodic edge correction method adjusts the K function estimate by creating periodic copies of the study region and the point pattern. This method assumes that the point pattern is periodic and that the study region’s shape and size repeat indefinitely in all directions. The periodic method works by creating multiple copies of the point pattern and the study region, shifting each copy by a multiple of the study region’s size, and then computing the average of the K function estimates obtained from each copy.</p> </li> </ul> <p><strong>Figure 2: Obeserved K Function vs Theoretical K function (CSR)</strong></p> <div class="row"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/bramblecanes_k_function-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/bramblecanes_k_function-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/bramblecanes_k_function-1400.webp"/> <img src="/assets/img/bramblecanes_k_function.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" title="Bramble Cane K Functions" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>Finally, we can compute and plot the L function:</p> <figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">L_hat</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">Lest</span><span class="p">(</span><span class="n">bramblecanes</span><span class="p">)</span><span class="w">
</span><span class="n">plot</span><span class="p">(</span><span class="n">L_hat</span><span class="p">,</span><span class="w"> </span><span class="n">main</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"L Function: L(r) - r"</span><span class="p">)</span></code></pre></figure> <p><strong>Figure 3: Obeserved L Function vs Theoretical L function (CSR)</strong></p> <div class="row"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/bramblecanes_l_function-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/bramblecanes_l_function-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/bramblecanes_l_function-1400.webp"/> <img src="/assets/img/bramblecanes_l_function.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" title="Bramble Cane L Functions" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <hr/> <h3 id="using-g-function">Using G Function</h3> <p>The G function, also known as the nearest-neighbor distance distribution function, is defined as the cumulative distribution function of the nearest-neighbor distances between points in the point pattern.</p> <p>The equation for the G function is:</p> \[G(r) = \frac{1}{n} \sum_{i=1}^{n}\sum_{j\neq i}^{n}I(d(x_i,x_j) \leq r)\] <p>where G(r) is the value of the G function at distance r, n is the number of points in the point pattern, I() is the indicator function that takes the value 1 if the distance between the ith and jth points in the point pattern is less than or equal to r, and 0 otherwise, and $d(x_i,x_j)$ is the Euclidean distance between the ith and jth points in the point pattern.</p> <p>In other words, the G function calculates the proportion of points in the point pattern that have at least one nearest neighbor within distance r. The G function can be used to test for spatial clustering or regularity in a point pattern. If the G function values are above or below the expected values under CSR, this suggests clustering or regularity, respectively.</p> <p>We can use the envelope function to construct the upper and lower bounds of the expected values of the <code class="language-plaintext highlighter-rouge">Gest</code> function under CSR. The envelope function is calculated by repeatedly simulating CSR point patterns within the study region and calculating the G function for each simulated pattern. The envelope function is then constructed by calculating the upper and lower percentiles of the simulated G function values for each distance. The resulting upper and lower envelopes are used to compare the observed Gest function values with the expected values under CSR.</p> <figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">gf.env</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">envelope</span><span class="p">(</span><span class="n">bramblecanes</span><span class="p">,</span><span class="w"> </span><span class="n">Gest</span><span class="p">,</span><span class="w"> </span><span class="n">correction</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"border"</span><span class="p">)</span><span class="w">
</span><span class="n">plot</span><span class="p">(</span><span class="n">gf.env</span><span class="p">)</span></code></pre></figure> <p><strong>Figure 4: Obeserved G Function vs Theoretical G function with Envelope (CSR)</strong></p> <div class="row"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/bramblecanes_g_function-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/bramblecanes_g_function-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/bramblecanes_g_function-1400.webp"/> <img src="/assets/img/bramblecanes_g_function.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" title="Bramble Cane G Functions" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <hr/> <h2 id="example-of-morans-i">Example of Moran’s I</h2> <h3 id="the-pennsylvania-lung-cancer-data">The Pennsylvania Lung Cancer Data</h3> <p>The <code class="language-plaintext highlighter-rouge">spatialepi</code> package in R contains several datasets related to the spatial analysis of epidemiological data. One of these datasets is the <code class="language-plaintext highlighter-rouge">pennLC</code> dataset, which contains information on lung cancer incidence rates in Pennsylvania by county in 2002.</p> <figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="c1"># Make sure the necessary packages have been loaded </span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="n">tmap</span><span class="p">)</span><span class="w"> 
</span><span class="n">library</span><span class="p">(</span><span class="n">tmaptools</span><span class="p">)</span><span class="w"> 
</span><span class="n">library</span><span class="p">(</span><span class="n">SpatialEpi</span><span class="p">)</span><span class="w"> 
</span><span class="n">library</span><span class="p">(</span><span class="n">sf</span><span class="p">)</span><span class="w">
</span><span class="c1"># Read in the Pennsylvania lung cancer data </span><span class="w">
</span><span class="n">data</span><span class="p">(</span><span class="n">pennLC</span><span class="p">)</span><span class="w">
</span><span class="c1"># Extract the SpatialPolygon info </span><span class="w">
</span><span class="n">penn.state.latlong</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">pennLC</span><span class="o">$</span><span class="n">spatial.polygon</span><span class="w"> 
</span><span class="c1"># Convert to UTM zone 17N </span><span class="w">
</span><span class="n">penn.state.latlong</span><span class="o">&lt;-</span><span class="w"> </span><span class="n">st_as_sf</span><span class="p">(</span><span class="n">penn.state.latlong</span><span class="p">)</span><span class="w">
</span><span class="n">penn.state.utm</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">set_projection</span><span class="p">(</span><span class="n">penn.state.latlong</span><span class="p">,</span><span class="w"> </span><span class="m">3724</span><span class="p">)</span><span class="w"> 
</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="s2">"sf"</span><span class="w"> </span><span class="o">%in%</span><span class="w"> </span><span class="nf">class</span><span class="p">(</span><span class="n">penn.state.latlong</span><span class="p">))</span><span class="w"> 
</span><span class="n">penn.state.utm</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">as</span><span class="p">(</span><span class="n">penn.state.utm</span><span class="p">,</span><span class="w"> </span><span class="s2">"Spatial"</span><span class="p">)</span><span class="w"> 
</span><span class="c1"># Obtain the smoking rates </span><span class="w">
</span><span class="n">penn.state.utm</span><span class="o">$</span><span class="n">smk</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">pennLC</span><span class="o">$</span><span class="n">smoking</span><span class="o">$</span><span class="n">smoking</span><span class="o">*</span><span class="m">100</span><span class="w"> 
</span><span class="c1"># Draw a choropleth map of the smoking rates</span><span class="w">
</span><span class="n">tm_shape</span><span class="p">(</span><span class="n">penn.state.utm</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">tm_polygons</span><span class="p">(</span><span class="n">col</span><span class="o">=</span><span class="s2">"smk"</span><span class="p">,</span><span class="w"> </span><span class="n">title</span><span class="o">=</span><span class="s2">"Percent of Population"</span><span class="p">)</span></code></pre></figure> <p><strong>Figure 5: Pennsylvania Smoking Rates</strong></p> <div class="row"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/Pennsylvania_smoking_uptake-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/Pennsylvania_smoking_uptake-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/Pennsylvania_smoking_uptake-1400.webp"/> <img src="/assets/img/Pennsylvania_smoking_uptake.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" title="Pennsyvania Smoking Rates" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="c1"># Set up a set of five 'fake' smoking update rates as well as the real one </span><span class="w">
</span><span class="c1"># Create new columns in penn.state.utm for randomised data </span><span class="w">
</span><span class="c1"># Here the seed 4676 is used. Use a different one to get an unknown outcome. </span><span class="w">
</span><span class="n">set.seed</span><span class="p">(</span><span class="m">4676</span><span class="p">)</span><span class="w">
</span><span class="n">penn.state.utm</span><span class="o">$</span><span class="n">smk_rand1</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">sample</span><span class="p">(</span><span class="n">penn.state.utm</span><span class="o">$</span><span class="n">smk</span><span class="p">)</span><span class="w"> 
</span><span class="n">penn.state.utm</span><span class="o">$</span><span class="n">smk_rand2</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">sample</span><span class="p">(</span><span class="n">penn.state.utm</span><span class="o">$</span><span class="n">smk</span><span class="p">)</span><span class="w"> 
</span><span class="n">penn.state.utm</span><span class="o">$</span><span class="n">smk_rand3</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">sample</span><span class="p">(</span><span class="n">penn.state.utm</span><span class="o">$</span><span class="n">smk</span><span class="p">)</span><span class="w"> 
</span><span class="n">penn.state.utm</span><span class="o">$</span><span class="n">smk_rand4</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">sample</span><span class="p">(</span><span class="n">penn.state.utm</span><span class="o">$</span><span class="n">smk</span><span class="p">)</span><span class="w"> 
</span><span class="n">penn.state.utm</span><span class="o">$</span><span class="n">smk_rand5</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">sample</span><span class="p">(</span><span class="n">penn.state.utm</span><span class="o">$</span><span class="n">smk</span><span class="p">)</span><span class="w"> 

</span><span class="c1"># Scramble the variables used in terms of plotting order </span><span class="w">
</span><span class="n">vars</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">sample</span><span class="p">(</span><span class="nf">c</span><span class="p">(</span><span class="s1">'smk'</span><span class="p">,</span><span class="s1">'smk_rand1'</span><span class="p">,</span><span class="s1">'smk_rand2'</span><span class="p">,</span><span class="s1">'smk_rand3'</span><span class="p">,</span><span class="s1">'smk_rand4'</span><span class="p">,</span><span class="s1">'smk_rand5'</span><span class="p">))</span><span class="w">

</span><span class="c1"># Which one will be the real data? </span><span class="w">
</span><span class="c1"># Don't look at this variable before you see the maps! </span><span class="w">
</span><span class="n">real.data.i</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">which</span><span class="p">(</span><span class="n">vars</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s1">'smk'</span><span class="p">)</span><span class="w"> 

</span><span class="c1"># Draw the scrambled map grid </span><span class="w">
</span><span class="n">tm_shape</span><span class="p">(</span><span class="n">penn.state.utm</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> 
  </span><span class="n">tm_polygons</span><span class="p">(</span><span class="n">col</span><span class="o">=</span><span class="n">vars</span><span class="p">,</span><span class="w"> </span><span class="n">legend.show</span><span class="o">=</span><span class="kc">FALSE</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> 
  </span><span class="n">tm_layout</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="w"> </span><span class="m">1</span><span class="o">:</span><span class="m">6</span><span class="p">,</span><span class="w"> </span><span class="n">title.position</span><span class="o">=</span><span class="nf">c</span><span class="p">(</span><span class="s2">"right"</span><span class="p">,</span><span class="s2">"top"</span><span class="p">))</span></code></pre></figure> <h3 id="visual-explotration-of-autocorrelation">Visual Explotration of Autocorrelation</h3> <p><strong>Figure 6: Randomized Pennsylvania Smoking Rates</strong></p> <div class="row"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/random_Pennsylvania_smoking_uptake-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/random_Pennsylvania_smoking_uptake-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/random_Pennsylvania_smoking_uptake-1400.webp"/> <img src="/assets/img/random_Pennsylvania_smoking_uptake.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" title="Randomized Pennsyvania Smoking Rates" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>Moran’s I is calculated using the formula:</p> \[I = \frac{n}{\sum_{i=1}^{n}\sum_{j=1}^{n}w_{ij}} \frac{\sum_{i=1}^{n}\sum_{j=1}^{n}w_{ij}(x_i - \bar{x})(x_j - \bar{x})}{\sum_{i=1}^{n}(x_i - \bar{x})^2}\] <p>where $n$ is the number of observations, $w_{ij}$ is the spatial weight between observation $i$ and observation $j$, $x_i$ is the value of the variable of interest for observation $i$, and $\bar{x}$ is the mean value of the variable of interest.</p> <p>The first term in the formula represents the spatial scale of analysis, or the effective number of neighboring observations. It is equal to $n$ divided by the sum of the spatial weights matrix $W$, which represents the total number of neighboring observations across all observations.</p> <p>The second term in the formula represents the spatial autocovariance of the variable of interest. It is calculated as the sum of the product of the spatial weight $w_{ij}$ between each pair of observations $i$ and $j$, and the difference between the variable value $x_i$ for observation $i$ and the mean value $\bar{x}$ of the variable across all observations, and the same difference for observation $j$. This term quantifies the degree to which similar values of the variable tend to be clustered together in space.</p> <p>The third term in the formula represents the overall variance of the variable of interest. It is calculated as the sum of the squared difference between the variable value $x_i$ for each observation $i$ and the mean value $\bar{x}$ of the variable across all observations. This term represents the total amount of variation in the variable across all observations.</p> <p>To calculate the spatial weights $w_{ij}$ for Moran’s I, there are several methods available, but the most common ones include the following:</p> <ol> <li>Binary contiguity: In this method, two observations are considered neighbors if they share a common boundary or vertex in a spatial domain. The spatial weight $w_{ij}$ is set to 1 if observation $i$ and $j$ are neighbors, and 0 otherwise.</li> </ol> \[w_{ij} = \begin{cases} 1, &amp; \text{if }i,j \text{ are neighbors}\\ 0, &amp; \text{otherwise} \end{cases}\] <ol> <li>Distance-based weights: In this method, spatial weights are calculated based on the distance between observations. The spatial weight $w_{ij}$ is set to a decreasing function of the distance between observation $i$ and $j$, such that observations that are closer together have a higher weight than those that are farther apart.</li> </ol> \[w_{ij} = \frac{1}{d_{ij}^p}\] <p>where $d_{ij}$ is the Euclidean distance between observations $i$ and $j$, and $p$ is a positive constant that controls the rate of decrease of the weight with distance.</p> <ol> <li>K-nearest neighbor weights: In this method, the spatial weight $w_{ij}$ is set to 1 if observation $j$ is one of the k-nearest neighbors of observation $i$, and 0 otherwise.</li> </ol> \[w_{ij} = \begin{cases} 1, &amp; \text{if }j \text{ is one of the k-nearest neighbors of }i\\ 0, &amp; \text{otherwise} \end{cases}\] <ol> <li>Kernel weights: In this method, spatial weights are calculated based on a continuous function that assigns weights to all observations in the study area, depending on their distance from the focal observation $i$. The spatial weight $w_{ij}$ is set to the value of the kernel function evaluated at the distance between observation $i$ and $j$.</li> </ol> \[w_{ij} = K\left(\frac{d_{ij}}{h}\right)\] <p>where $K$ is the kernel function, $d_{ij}$ is the Euclidean distance between observations $i$ and $j$, and $h$ is a positive constant that controls the bandwidth of the kernel. Commonly used kernel functions include the Gaussian, uniform, and triangular kernels.</p> <ol> <li>Lagged mean weights: In this method, spatial weights are calculated based on the average value of the variable of interest for neighboring observations. The spatial weight $w_{ij}$ is set to the ratio of the deviation of the value of observation $j$ from the mean of all neighboring observations of observation $i$, divided by the variance of the variable.</li> </ol> \[w_{ij} = \frac{x_j - \bar{x}_{N_i}}{\sum_{k \in N_i}(x_k - \bar{x}_{N_i})^2}\] <p>where $x_j$ is the value of the variable for observation $j$, $\bar{x}_{N_i}$ is the mean value of the variable for all observations in the neighborhood of observation $i$ (excluding observation $i$ itself), and $N_i$ is the set of neighbors of observation $i$. This method accounts for spatial autocorrelation in the variable of interest by estimating the local variance of the variable based on neighboring observations.</p> <p>Note that the lagged mean method assumes that the relationship between neighboring observations is linear and stationary. It may not be appropriate for non-linear or non-stationary</p> <figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">require</span><span class="p">(</span><span class="n">spdep</span><span class="p">)</span><span class="w">
</span><span class="c1"># Calculate spatial weights matrix</span><span class="w">
</span><span class="n">nb</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">poly2nb</span><span class="p">(</span><span class="n">penn.state.utm</span><span class="p">,</span><span class="w"> </span><span class="n">queen</span><span class="o">=</span><span class="kc">TRUE</span><span class="p">)</span><span class="w">
</span><span class="n">W</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">nb2listw</span><span class="p">(</span><span class="n">nb</span><span class="p">)</span><span class="w">

</span><span class="c1"># Calculate Moran's I for smoking rates</span><span class="w">
</span><span class="n">moran</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">moran.test</span><span class="p">(</span><span class="n">penn.state.utm</span><span class="o">$</span><span class="n">smk</span><span class="p">,</span><span class="w"> </span><span class="n">listw</span><span class="o">=</span><span class="n">W</span><span class="p">)</span><span class="w">

</span><span class="c1"># Print Moran's I results</span><span class="w">
</span><span class="n">cat</span><span class="p">(</span><span class="s2">"Moran's I for smoking rates:"</span><span class="p">,</span><span class="w"> </span><span class="n">moran</span><span class="o">$</span><span class="n">estimate</span><span class="p">[</span><span class="m">1</span><span class="p">],</span><span class="w"> </span><span class="s2">"\n"</span><span class="p">)</span><span class="w">
</span><span class="n">cat</span><span class="p">(</span><span class="s2">"p-value:"</span><span class="p">,</span><span class="w"> </span><span class="n">moran</span><span class="o">$</span><span class="n">p.value</span><span class="p">,</span><span class="w"> </span><span class="s2">"\n"</span><span class="p">)</span></code></pre></figure>]]></content><author><name>Kenan Li</name></author><category term="Tutorial"/><summary type="html"><![CDATA[An introduction to computing spatial Randomness and autocorrelation in R with examples]]></summary></entry><entry><title type="html">Besag-York-Mollié (BYM) model</title><link href="https://kenan-li.github.io/blog/2023/BYM-Model/" rel="alternate" type="text/html" title="Besag-York-Mollié (BYM) model"/><published>2023-04-03T00:00:00+00:00</published><updated>2023-04-03T00:00:00+00:00</updated><id>https://kenan-li.github.io/blog/2023/BYM-Model</id><content type="html" xml:base="https://kenan-li.github.io/blog/2023/BYM-Model/"><![CDATA[<h2 id="background">Background</h2> <p>The BYM model, also known as the Besag-York-Mollié model, is a spatial statistical model used for analyzing disease mapping and other spatially structured data. Named after its developers Julian Besag, Jeremy York, and Annie Mollié, it was introduced in their 1991 paper titled “Bayesian Image Restoration, with Two Applications in Spatial Statistics.”</p> <p>The BYM model is a hierarchical Bayesian model that incorporates both spatially structured and unstructured random effects to account for spatial autocorrelation and overdispersion in the data. The model can be represented as:</p> \[Y_i \sim Poisson(E_i * exp(α + U_i + V_i))\quad\quad (1)\] <p>where:</p> <p>$Y_i$ is the observed number of cases in area i $E_i$ is the expected number of cases in area i α is the overall log-relative risk $U_i$ is the spatially unstructured random effect for area i $V_i$ is the spatially structured random effect for area i The spatially structured component ($V_i$) captures the spatial dependence between neighboring areas, while the unstructured component ($U_i$) accounts for any remaining variability not explained by the structured component.</p> <p>It is a special case of the conditional autoregressive (CAR) model. In a CAR model, the response variable in each area is modeled as a linear combination of its neighboring areas, conditional on the values of the response variable in the other areas. This means that the spatial dependence is modeled indirectly through a conditional distribution, and the weights used to define the spatial relationship between areas are conditional on the values of the response variable.</p> <h3 id="application">Application</h3> <p>The BYM model is useful in various applications where spatially structured data is of interest. Here are a few real-world examples where the BYM model can be applied:</p> <p>Disease mapping and epidemiology: The BYM model can be used to analyze the spatial distribution of diseases, identify areas with unusually high or low disease incidence, and estimate relative risks. This information can help public health authorities allocate resources and target interventions more effectively. For example, the BYM model can be applied to study the spatial distribution of cancer cases, malaria, or COVID-19.</p> <p>Environmental risk assessment: The BYM model can be applied to assess environmental risks associated with air pollution, water contamination, or soil pollution. By understanding the spatial patterns of pollutants or hazardous substances, researchers can identify areas with increased risk and inform policy decisions aimed at reducing exposure.</p> <p>Crime analysis: The BYM model can be used to study the spatial distribution of crime incidents and identify hotspots. This information can help law enforcement agencies allocate resources and develop targeted strategies to reduce crime in specific areas.</p> <p>Biodiversity and species distribution: The BYM model can be applied to study the spatial distribution of different species and identify areas with high or low biodiversity. This can help guide conservation efforts, habitat restoration, and wildlife management strategies.</p> <h2 id="advantages">Advantages</h2> <p>Spatial autocorrelation: The BYM model accounts for spatial autocorrelation by incorporating a spatially structured random effect. This enables the model to capture spatial patterns in the data more accurately than non-spatial models.</p> <p>Overdispersion: The BYM model includes an unstructured random effect to account for overdispersion in the data, which is common in count data, such as disease cases or crime incidents.</p> <p>Hierarchical Bayesian framework: The BYM model is a hierarchical Bayesian model, which allows for the incorporation of prior information and provides a coherent framework for uncertainty quantification. This makes the model robust and interpretable.</p> <p>Flexibility: The BYM model is flexible and can be extended to incorporate additional covariates, random effects, or more complex spatial structures. This makes it suitable for a wide range of applications and data types.</p> <h2 id="implementation-in-r">Implementation in R</h2> <p>To illustrate the use of the BYM model in R, we will use the INLA package, which provides an efficient approach to fitting spatial models using Integrated Nested Laplace Approximation (INLA). In this example, we’ll simulate some spatial data and fit the BYM model to it.</p> <p>First, install and load the necessary packages:</p> <figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">install.packages</span><span class="p">(</span><span class="s2">"INLA"</span><span class="p">,</span><span class="w"> </span><span class="n">repos</span><span class="o">=</span><span class="nf">c</span><span class="p">(</span><span class="s2">"https://inla.r-inla-download.org/R/stable"</span><span class="p">,</span><span class="w"> </span><span class="n">getOption</span><span class="p">(</span><span class="s2">"repos"</span><span class="p">)))</span><span class="w">
</span><span class="n">install.packages</span><span class="p">(</span><span class="s2">"spdep"</span><span class="p">)</span><span class="w">  </span><span class="c1"># For spatial data manipulation</span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="n">INLA</span><span class="p">)</span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="n">spdep</span><span class="p">)</span></code></pre></figure> <p>The following example will show how to create a synthetic spatial dataset, generate the BYM model components, fit the model, and visualize the results:</p> <figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="c1">#------------------------------------------------------------------------------</span><span class="w">
</span><span class="c1">#-</span><span class="w">
</span><span class="c1">#-  North Carolina SIDS data</span><span class="w">
</span><span class="c1">#-</span><span class="w">
</span><span class="c1">#-    From Roger Bivand's web site  </span><span class="w">
</span><span class="c1">#-</span><span class="w">
</span><span class="c1">#-    https://r-spatial.github.io/spdep/articles/sids.html</span><span class="w">
</span><span class="c1">#-</span><span class="w">
</span><span class="c1">#------------------------------------------------------------------------------</span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="w"> </span><span class="n">spdep</span><span class="w"> </span><span class="p">)</span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="w"> </span><span class="n">tmap</span><span class="w"> </span><span class="p">)</span><span class="w">
</span><span class="n">nc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">st_read</span><span class="p">(</span><span class="w"> </span><span class="n">system.file</span><span class="p">(</span><span class="s2">"shapes/sids.shp"</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">package</span><span class="o">=</span><span class="s2">"spData"</span><span class="w"> </span><span class="p">)[</span><span class="m">1</span><span class="p">]</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">quiet</span><span class="o">=</span><span class="kc">TRUE</span><span class="w"> </span><span class="p">)</span><span class="w">
</span><span class="n">st_crs</span><span class="p">(</span><span class="n">nc</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"+proj=longlat +datum=NAD27"</span><span class="w">
</span><span class="n">row.names</span><span class="p">(</span><span class="n">nc</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">as.character</span><span class="p">(</span><span class="n">nc</span><span class="o">$</span><span class="n">FIPSNO</span><span class="p">)</span><span class="w">
</span><span class="nf">class</span><span class="p">(</span><span class="w"> </span><span class="n">nc</span><span class="w"> </span><span class="p">)</span><span class="w">
</span><span class="n">nc</span><span class="o">$</span><span class="n">SIDSrate79</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nc</span><span class="o">$</span><span class="n">SID79</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">nc</span><span class="o">$</span><span class="n">BIR79</span><span class="w">


</span><span class="n">tm_shape</span><span class="p">(</span><span class="w"> </span><span class="n">nc</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w">
  </span><span class="n">tm_borders</span><span class="p">(</span><span class="w"> </span><span class="n">lwd</span><span class="o">=</span><span class="m">2</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w">
  </span><span class="n">tm_fill</span><span class="p">(</span><span class="w"> </span><span class="n">col</span><span class="o">=</span><span class="s2">"SIDSrate79"</span><span class="w"> </span><span class="p">)</span><span class="w">

</span><span class="n">nb</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">poly2nb</span><span class="p">(</span><span class="w"> </span><span class="n">nc</span><span class="w"> </span><span class="p">)</span><span class="w">
</span><span class="n">nb2INLA</span><span class="p">(</span><span class="w"> </span><span class="s2">"nc.adj"</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">nb</span><span class="w"> </span><span class="p">)</span><span class="w">
</span><span class="n">g</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">inla.read.graph</span><span class="p">(</span><span class="w"> </span><span class="n">filename</span><span class="o">=</span><span class="s2">"nc.adj"</span><span class="w"> </span><span class="p">)</span><span class="w">
</span><span class="n">hyperPriors</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">list</span><span class="p">(</span><span class="w"> </span><span class="n">prec.unstruct</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">list</span><span class="p">(</span><span class="n">prior</span><span class="o">=</span><span class="s2">"loggamma"</span><span class="p">,</span><span class="n">param</span><span class="o">=</span><span class="nf">c</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="m">0.01</span><span class="p">))</span><span class="w"> </span><span class="p">,</span><span class="w">
                    </span><span class="n">prec.spatial</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="nf">list</span><span class="p">(</span><span class="n">prior</span><span class="o">=</span><span class="s2">"loggamma"</span><span class="p">,</span><span class="n">param</span><span class="o">=</span><span class="nf">c</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="m">0.01</span><span class="p">))</span><span class="w">  </span><span class="p">)</span><span class="w"> 
</span><span class="n">nc</span><span class="o">$</span><span class="n">NWBIRrate79</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nc</span><span class="o">$</span><span class="n">NWBIR79</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">nc</span><span class="o">$</span><span class="n">BIR79</span><span class="w">

</span><span class="n">nc</span><span class="o">$</span><span class="n">ID</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1</span><span class="o">:</span><span class="n">nrow</span><span class="p">(</span><span class="n">nc</span><span class="p">)</span><span class="w">
</span><span class="n">formula</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="n">SID79</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="n">NWBIRrate79</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="w"> </span><span class="n">ID</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">model</span><span class="o">=</span><span class="s2">"bym"</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">graph</span><span class="o">=</span><span class="n">g</span><span class="w"> </span><span class="p">,</span><span class="w"> 
                                    </span><span class="n">hyper</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">hyperPriors</span><span class="w"> </span><span class="p">)</span><span class="w">

</span><span class="n">mod</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">inla</span><span class="p">(</span><span class="w"> </span><span class="n">formula</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">family</span><span class="o">=</span><span class="s2">"poisson"</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="o">=</span><span class="n">nc</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">offset</span><span class="o">=</span><span class="nf">log</span><span class="p">(</span><span class="n">BIR79</span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w">
</span><span class="n">summary</span><span class="p">(</span><span class="w"> </span><span class="n">mod</span><span class="w"> </span><span class="p">)</span><span class="w">

</span><span class="n">mod</span><span class="o">$</span><span class="n">summary.fixed</span><span class="o">$</span><span class="n">mean</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="w">
</span><span class="n">mod</span><span class="o">$</span><span class="n">summary.fixed</span><span class="o">$</span><span class="n">mean</span><span class="p">[</span><span class="m">2</span><span class="p">]</span></code></pre></figure> <p><strong>Figure 1: SIDS Rate 79</strong></p> <div class="row"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/BYM_INLA-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/BYM_INLA-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/BYM_INLA-1400.webp"/> <img src="/assets/img/BYM_INLA.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" title="SIDS Rate 79" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div>]]></content><author><name>Kenan Li</name></author><category term="Tutorial"/><summary type="html"><![CDATA[An introduction to BYM model in R with examples]]></summary></entry><entry><title type="html">Kriging Interpolation in R</title><link href="https://kenan-li.github.io/blog/2023/Kriging/" rel="alternate" type="text/html" title="Kriging Interpolation in R"/><published>2023-03-08T00:00:00+00:00</published><updated>2023-03-08T00:00:00+00:00</updated><id>https://kenan-li.github.io/blog/2023/Kriging</id><content type="html" xml:base="https://kenan-li.github.io/blog/2023/Kriging/"><![CDATA[<h2 id="introduction">Introduction</h2> <p>Spatial interpolation techniques are used to estimate the values of variables at unsampled locations based on the values of the same variable at sampled locations. One of the popular spatial interpolation techniques used in geostatistics is Kriging interpolation. Kriging interpolation is a powerful statistical method that allows one to predict the values of variables at unsampled locations while also accounting for spatial autocorrelation.</p> <p>In this tutorial, we will go through the basic concepts of Kriging interpolation, the types of Kriging, and how to implement the method in R using the <code class="language-plaintext highlighter-rouge">gstat</code> library.</p> <h3 id="basic-concepts">Basic Concepts</h3> <p>Kriging is based on the assumption that the spatial correlation between observations decreases with distance, and that this correlation can be modeled using a mathematical function.</p> <p>The basic idea of kriging is to find a set of weights that can be used to combine the observed values at nearby locations to estimate the value at the target location. The weights are chosen to minimize the variance of the estimation error, subject to the constraint that the estimated value is a linear combination of the observed values.</p> <p>The kriging estimator can be written as:</p> \[\hat{Z}(s_0)=\sum_{i=1}^n \lambda_i Z(s_i) \quad\quad (1)\] <p>where \(\hat{Z}(s_0)\) is the estimated value at the target location s, \(Z(s_i)\) is the observed value at location i, \(\lambda_i\) is the weight assigned to the observed value at location i, and \(n\) is the number of observed locations.</p> <p>The weights are typically chosen to minimize the estimation variance \(\sigma^2\), which is given by:</p> \[min\ \ \ \sigma^2 = E \left[ Z(s_0)-\sum_{i=1}^n \lambda_i Z(s_i) \right] \quad\quad (2)\] <p>The weights \(\lambda_i\) are chosen to minimize the estimation variance subject to the constraint that they sum to one:</p> \[\sum_{i=1}^n \lambda_i = 1 \quad\quad (3)\] <h3 id="empirical-semivariogram">Empirical Semivariogram</h3> <p>Semivariogram is a tool commonly used in geostatistics to analyze spatial autocorrelation in data. It is a measure of the dissimilarity between pairs of values at different locations within a dataset. Semivariogram can provide insights into the spatial structure of data, which can be useful in predicting values at unobserved locations through kriging interpolation.</p> <p>The empirical semivariogram is defined as the average squared difference between pairs of observations separated by a certain distance or lag, and is expressed mathematically as:</p> \[\gamma(h) = \frac{1}{2N(h)} \sum_{i=1}^{n} \sum_{|s_j-s_i| &lt; h} [Z(s_i)-Z(s_j)]^2 \quad\quad (4)\] <p>where \(\gamma(h)\) is the semivariance for a lag distance \(h\), \(N(h)\) is the number of pairs of observations separated by the distance \(h\), and \(Z(s_i)\) is the value of the variable at location \(s_i\).</p> <p>The empirical semivariogram is typically plotted as a function of lag distance, which shows how the dissimilarity between pairs of observations changes as the distance between them increases. The shape of the semivariogram curve can provide insights into the spatial structure of the data.</p> <p>In kriging interpolation, the semivariogram is used to estimate the spatial autocorrelation of the variable being modeled. The semivariogram model is then used to estimate the variance of the estimation errors \(\sigma^2\) at unobserved locations, which is used to calculate the kriging weights. The kriging weights are then used to calculate the estimated value at the unobserved location.</p> <h3 id="modeling-semivariogram">Modeling Semivariogram</h3> <p>Empirical semivariogram does not assume under underlying spatial structure of the data. In order to use semivariogram for spatial prediction through kriging interpolation or other geostatistical techniques, it is necessary to model the spatial autocorrelation structure of the data using a theoretical semivariogram model.</p> <p>These models typically have a covariance function that describes the expected correlation between pairs of observations at different distances, based on assumptions about the underlying spatial structure of the data. Table 1 listed some commonly used covariance functions.</p> <p><strong>Table 1: Some Semivariogram Functions</strong> <d-footnote>$^*$ where $C(h)$ is the semivariance at lag distance $h$, $c$ is the sill (maximum semivariance), $a$ is the range (distance at which the semivariance reaches the sill), $\nu$ is a smoothness parameter, $\Gamma(\nu)$ is the gamma function, and $K_\nu$ is the modified Bessel function of the second kind of order $\nu$.</d-footnote></p> <table> <thead> <tr> <th>Name</th> <th style="text-align: center">Function From</th> </tr> </thead> <tbody> <tr> <td>Exponential</td> <td style="text-align: center">\(C(h) = c \left[1 - \exp\left(-\frac{h}{a}\right)\right]\)</td> </tr> <tr> <td>Gaussian</td> <td style="text-align: center">\(C(h) = c \left[1 - \exp\left(-\frac{h^2}{a^2}\right)\right]\)</td> </tr> <tr> <td>Matérn</td> <td style="text-align: center">\(C(h) = \frac{\sigma^2}{\Gamma(\nu) 2^{\nu-1}} \left(\frac{\sqrt{2\nu}}{a}h\right)^\nu K_\nu\left(\frac{\sqrt{2\nu}}{a}h\right)\)</td> </tr> <tr> <td>Spherical</td> <td style="text-align: center">\(C(h) = c \left[1.5 \frac{h}{a} - 0.5 \left(\frac{h}{a}\right)^3\right] \quad \text{for } h \le a\)</td> </tr> </tbody> </table> <p>Fitting a semivariogram model to the empirical semivariogram involves estimating the parameters of the model, such as the sill, range, and smoothness parameter, that best describe the spatial autocorrelation structure of the data. This is typically done through solving a least-squares problem, where the goal is to minimize the sum of the squared differences between the empirical semivariogram and the semivariogram model predictions at different lag distances.</p> <p>The following steps outline the basic procedure for fitting a semivariogram model to the empirical semivariogram:</p> <ol> <li> <p>Calculate the empirical semivariogram for the dataset using Equation 4.</p> </li> <li> <p>Choose a covariance function that is appropriate for the spatial autocorrelation structure of the data. This can be based on visual inspection of the empirical semivariogram, or on prior knowledge of the data.</p> </li> <li> <p>Estimate the parameters of the semivariogram model. This involves finding the values of the model parameters that minimize the sum of the squared differences between the predicted semivariance values from the model and the observed semivariance values from the empirical semivariogram.</p> </li> <li> <p>Evaluate the goodness of fit of the semivariogram model to the empirical semivariogram. This can be done using various statistical measures, such as the coefficient of determination (\(R^2\)), the root mean squared error (RMSE), or the Akaike information criterion (AIC).</p> </li> <li> <p>Use the fitted semivariogram model to make spatial predictions through kriging interpolation or other geostatistical techniques.</p> </li> </ol> <p>It is important to note that the choice of semivariogram model and the method used for parameter estimation can have a significant impact on the accuracy and reliability of the spatial predictions. It is therefore important to carefully evaluate the performance of different semivariogram models and parameter estimation methods before making spatial predictions.</p> <p>It is also important to note that the covariance function and the empirical semivariogram are two related concepts in geostatistics, but they are not the same thing. The covariance function describes the relationship between two spatial locations in terms of their similarity or dissimilarity. It is a mathematical function that specifies the covariance or correlation between two locations as a function of their distance or lag. The covariance function is typically used in kriging to estimate the unknown value of a variable at an unsampled location as a linear combination of the observed values at nearby locations, weighted by their covariance with the unsampled location.</p> <p>The semivariogram, on the other hand, is a measure of spatial dependence or autocorrelation in a variable. It is defined as half the variance of the differences between pairs of values separated by a certain lag or distance. The semivariogram is a graphical representation of the spatial structure of the variable, showing how the similarity between values decreases with increasing distance or lag. The semivariogram is often used in geostatistics to estimate the covariance function, by fitting a model to the empirical semivariogram.</p> <h3 id="types-of-kriging">Types of kriging</h3> <p>There are various types of kriging, including ordinary kriging, simple kriging, and universal kriging, which differ in their assumptions about the mean of the unknown variable and the spatial covariance function.</p> <ol> <li> <p>Ordinary kriging:</p> <p>Ordinary kriging assumes that the mean of the unknown variable \(\mu\) is unknown and that the covariance between the variable at any two locations depends only on the distance between the locations (intrisical stationarity). The model assumption can be written as:</p> \[Z(s) = \mu + \delta(s) \quad\quad (5)\] <p>where \(\delta(s)\) is a zero mean stochastic term, and \(\mu\) is the unknown mean of the variable. For intrinsically stationary process, Equation 2 can be written as (a detailed proof can be found here<d-cite key="christoffersson2018"></d-cite>):</p> \[\sigma^2 = 2\sum_{i=1}^{n}\lambda_i\gamma(s_0, s_i) - \sum_{i=1}^{n}\sum_{j=1}^{n}\lambda_i\lambda_j\gamma(s_i, s_j) \quad\quad (6)\] <p>Using matrix notation and covariance function \(C(s_i, s_j)\) to model semivariogram \(\gamma(s_i, s_j)\), the kriging system of equations for ordinary kriging can be written as:</p> \[\begin{bmatrix}C(s_1, s_1) &amp; C(s_1, s_2) &amp; \cdots &amp; C(s_1, s_n) &amp; 1\\C(s_2, s_1) &amp; C(s_2, s_2) &amp; \cdots &amp; C(s_2, s_n) &amp; 1\\\vdots &amp; \vdots&amp; \ddots &amp; \vdots &amp; \vdots\\C(s_n, s_1) &amp; C(s_n, s_2) &amp; \cdots &amp; C(s_n, s_n) &amp; 1\\1 &amp; 1 &amp; \cdots &amp; 1 &amp; 0\end{bmatrix}\begin{bmatrix}\lambda_1\\\lambda_2\\\vdots\\\lambda_n\\\hat{\mu}\end{bmatrix} = \begin{bmatrix}C(s_1, s_0)\\C(s_2, s_0)\\\vdots\\C(s_n, s_0)\\1\end{bmatrix}\] <p>where \(\hat{\mu}\) is the estimated mean of the variable, and the additional row and column of 1’s correspond to the constraint that the weights sum to 1 and the assumption that the mean of the variable is unknown. The weights \(\lambda_i\) are chosen to minimize the estimation variance subject to the constraint that they sum to one.</p> </li> <li> <p>Simple kriging:</p> <p>Simple kriging assumes that the mean of the unknown variable is known and that the covariance between the variable at any two locations depends only on the distance between the locations. The kriging system of equations for simple kriging can be written as:</p> \[\begin{bmatrix}C(s_1, s_1) &amp; C(s_1, s_2) &amp; \cdots &amp; C(s_1, s_n)\\C(s_2, s_1) &amp; C(s_2, s_2) &amp; \cdots &amp; C(s_2, s_n)\\\vdots &amp; \vdots&amp; \ddots &amp; \vdots\\C(s_n, s_1) &amp; C(s_n, s_2) &amp; \cdots &amp; C(s_n, s_n)\end{bmatrix}\begin{bmatrix}\lambda_1\\\lambda_2\\\vdots\\\lambda_n\end{bmatrix} = \begin{bmatrix}C(s_1, s_0)-\mu\\C(s_2, s_0)-\mu\\\vdots\\C(s_n, s_0)-\mu\end{bmatrix}\] <p>where \(\mu\) is the known mean of the variable and the weights \(\lambda\) are chosen to minimize the estimation variance subject to the constraint that they sum to one.</p> </li> <li> <p>Universal kriging:</p> <p>Universal kriging assumes that the mean of the unknown variable can be modeled using a known function of the spatial coordinates and/or covariates (drift or trend term), such as a linear or quadratic function. The covariance between the variable at any two locations depends on depends only on the distance between the locations. The universal kriging estimator at an unsampled location \(s\) is given by:</p> \[Z(s) = \sum_{j=1}^{p} \beta_j v_j(s) + \delta(s) \quad\quad (7)\] <p>where \(\beta_j\) are the coefficients of the drift term in the regression model, and \(v_j(s)\) is the value of the $j$th covariate at location \(s\).</p> <p>The kriging system of equations for universal kriging can be written as:</p> </li> </ol> \[\begin{bmatrix} C(s_1, s_1) &amp; \cdots &amp; C(s_1, s_n) &amp; v_1(s_1) &amp; \cdots &amp; v_p(s_1) \\ \vdots &amp; \ddots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ C(s_n, s_1) &amp; \cdots &amp; C(s_n, s_n) &amp; v_1(s_n) &amp; \cdots &amp; v_p(s_n) \\ v_1(s_1) &amp; \cdots &amp; v_1(s_n) &amp; 0 &amp; \cdots &amp; 0 \\ \vdots &amp; \ddots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ v_p(s_1) &amp; \cdots &amp; v_p(s_n) &amp; 0 &amp; \cdots &amp; 0 \end{bmatrix} \begin{bmatrix} \lambda_1 \\ \vdots \\ \lambda_n \\ -\beta_1 \\ \vdots \\ -\beta_p \end{bmatrix} = \begin{bmatrix} C(s_1,s_0) \\ \vdots \\ C(s_n,s_0) \\ v_1(s_0) \\ \vdots \\ v_p(s_0) \end{bmatrix}\] <p>where \(C(s_i, s_j)\) represents the covariance between locations \(s_i\) and \(s_j\) in the presence of a drift term, \(C(s_i,s_0)\) represents the semivariance between the unsampled location and location \(s_i\), \(\lambda_i\) represents the kriging weights for each sampled location, \(\mu\) represents the kriging estimate of the mean value, \(\beta_j\) represents the coefficients of the drift term in the regression model, and \(v_j(s_i)\) represents the value of the \(j\)th covariate at location \(s_i\).</p> <hr/> <h2 id="implementation">Implementation</h2> <h3 id="fitting-semivariogram">Fitting Semivariogram</h3> <p>The implementation example used in this task is based on the book “An Introduction to R for Spatial Analysis and Mapping” by Brunsdon and Comber<d-cite key="brunsdoncomber2018"></d-cite>. Before following the example, you must install the <code class="language-plaintext highlighter-rouge">gstat</code> R library in your R environment. The <code class="language-plaintext highlighter-rouge">gstat</code> library is designed for geostatistical modeling and spatial data analysis in R, providing a wide range of tools for spatial data exploration, variogram modeling, kriging, and spatial prediction.</p> <p>We will be using the <code class="language-plaintext highlighter-rouge">fulmar</code> dataset included in the gstat library to practice kriging interpolation. The <code class="language-plaintext highlighter-rouge">fulmar</code> dataset contains airborne counts of the sea bird Fulmaris glacialis during August and September of 1998 and 1999 over the Dutch part of the North Sea. The counts are taken along transects corresponding to flight paths of the observation aircraft and are transformed to densities by dividing counts by the area of observation, which is \(0.5 km^2\).</p> <p>The codes below plots the kriging semivariogram of the <code class="language-plaintext highlighter-rouge">fulmar</code> dataset:</p> <figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="c1"># Load the gstat library</span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="n">gstat</span><span class="p">)</span><span class="w">

</span><span class="c1"># Load the fulmar dataset from the gstat library</span><span class="w">
</span><span class="n">data</span><span class="p">(</span><span class="s2">"fulmar"</span><span class="p">)</span><span class="w">

</span><span class="c1"># Create a SpatialPointsDataFrame object from the fulmar dataset</span><span class="w">
</span><span class="c1"># The cbind function combines the x and y coordinates into a matrix, which is used to create the SpatialPointsDataFrame</span><span class="w">
</span><span class="n">fulmar.spdf</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">SpatialPointsDataFrame</span><span class="p">(</span><span class="n">cbind</span><span class="p">(</span><span class="n">fulmar</span><span class="o">$</span><span class="n">x</span><span class="p">,</span><span class="n">fulmar</span><span class="o">$</span><span class="n">y</span><span class="p">),</span><span class="w"> </span><span class="n">fulmar</span><span class="p">)</span><span class="w">

</span><span class="c1"># Calculate the empirical variogram of the 'fulmar' variable in the fulmar.spdf dataset</span><span class="w">
</span><span class="c1"># The 'fulmar~1' formula specifies the variable to be analyzed and '1' indicates that there are no covariates</span><span class="w">
</span><span class="c1"># The 'boundaries' argument sets the distance lags for the variogram calculation</span><span class="w">
</span><span class="n">evgm</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">variogram</span><span class="p">(</span><span class="n">fulmar</span><span class="o">~</span><span class="m">1</span><span class="p">,</span><span class="n">fulmar.spdf</span><span class="p">,</span><span class="w"> </span><span class="n">boundaries</span><span class="o">=</span><span class="n">seq</span><span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="m">250000</span><span class="p">,</span><span class="n">l</span><span class="o">=</span><span class="m">51</span><span class="p">))</span><span class="w">

</span><span class="c1"># Fit a variogram model to the experimental variogram</span><span class="w">
</span><span class="c1"># The 'vgm' function specifies the type of variogram model to be used</span><span class="w">
</span><span class="c1"># Here, a Matérn model with a sill of 3, a range of 100000 and a nugget of 1 is used</span><span class="w">
</span><span class="n">fvgm</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">fit.variogram</span><span class="p">(</span><span class="n">evgm</span><span class="p">,</span><span class="n">vgm</span><span class="p">(</span><span class="m">3</span><span class="p">,</span><span class="s2">"Mat"</span><span class="p">,</span><span class="m">100000</span><span class="p">,</span><span class="m">1</span><span class="p">))</span><span class="w">

</span><span class="c1"># Plot the experimental variogram with the fitted variogram model</span><span class="w">
</span><span class="c1"># The 'model' argument specifies the fitted variogram model to be plotted</span><span class="w">
</span><span class="n">plot</span><span class="p">(</span><span class="n">evgm</span><span class="p">,</span><span class="n">model</span><span class="o">=</span><span class="n">fvgm</span><span class="p">)</span></code></pre></figure> <p>The <code class="language-plaintext highlighter-rouge">variogram()</code> function computes the empirical variogram, and takes the following key arguments:</p> <ul> <li><code class="language-plaintext highlighter-rouge">formula</code>: A formula specifying the variables to be used in the calculation of the variogram. The formula takes the form <code class="language-plaintext highlighter-rouge">response</code> ~ <code class="language-plaintext highlighter-rouge">predictor</code>, where <code class="language-plaintext highlighter-rouge">response</code> is the variable to be analyzed and <code class="language-plaintext highlighter-rouge">predictor</code> is an optional covariate or drift term. The covariate can be a numeric or factor variable, and the drift term can be specified as 1 for <code class="language-plaintext highlighter-rouge">ordinary kriging</code>.</li> <li><code class="language-plaintext highlighter-rouge">data</code>: A spatial data object containing the variables specified in the formula argument.</li> <li><code class="language-plaintext highlighter-rouge">width</code>: The maximum lag distance between pairs of sample locations. If not specified, the function will determine the maximum lag distance based on the data.</li> </ul> <p><strong>Figure 1: Matérn Semivariogram of Fulmar Counts in the North Sea</strong></p> <div class="row"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/fulmar_variogram-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/fulmar_variogram-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/fulmar_variogram-1400.webp"/> <img src="/assets/img/fulmar_variogram.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" title="Matérn Semivariogram of Fulmar Counts in the North Sea" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <h3 id="nugget">Nugget</h3> <p>In <code class="language-plaintext highlighter-rouge">vgm(3,"Mat",100000,1)</code>, the <code class="language-plaintext highlighter-rouge">nugget</code> argumaent refers to the intercept of the variogram at zero distance or lag. It represents the spatial variability that cannot be explained by the spatial autocorrelation in the data, such as measurement error or microscale variation.</p> <p>The nugget effect is an important concept in variogram modeling because it affects the shape of the variogram and the spatial prediction derived from it. A large nugget effect indicates that there is a high degree of spatial variability at small distances or lags, which can lead to difficulties in spatial interpolation and prediction. On the other hand, a small nugget effect indicates that the spatial variability is primarily driven by spatial autocorrelation, making it easier to predict the value of the variable at unsampled locations.</p> <p>Variogram models that account for the nugget effect can be used to estimate the spatial correlation structure of the data and to make predictions at unsampled locations based on that structure. Different types of variogram models, such as exponential, Gaussian, and Matérn, incorporate the nugget effect in different ways and may be more appropriate for certain types of data or spatial structures.</p> <h3 id="running-kriging">Running Kriging</h3> <p>Now we can perform kriging interpolation using the variogram model. Run the following code:</p> <figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">s.grid</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">spsample</span><span class="p">(</span><span class="n">fulmar.spdf</span><span class="p">,</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"regular"</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">6000</span><span class="p">)</span><span class="w">
</span><span class="n">krig.est</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">krige</span><span class="p">(</span><span class="n">fulmar</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="n">fulmar.spdf</span><span class="p">,</span><span class="w"> </span><span class="n">newdata</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s.grid</span><span class="p">,</span><span class="w"> </span><span class="n">model</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fvgm</span><span class="p">)</span></code></pre></figure> <p>This code creates a variogram model from the <code class="language-plaintext highlighter-rouge">fulmar</code> data and uses it to perform kriging interpolation on the <code class="language-plaintext highlighter-rouge">s.grid</code> object. The points at which estimates are made are supplied in <code class="language-plaintext highlighter-rouge">s.grid</code>. The <code class="language-plaintext highlighter-rouge">krige()</code> function returns a <code class="language-plaintext highlighter-rouge">SpatialPointsDataFrame</code> object containing the kriging estimates.</p> <p>To create a choropleth map of the kriging estimates, we need to convert the kriging results to a <code class="language-plaintext highlighter-rouge">SpatialPixelsDataFrame</code> object and define a color palette for the map. We also need to define break values for the estimate variance map. Run the following code:</p> <figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">krig.grid</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">SpatialPixelsDataFrame</span><span class="p">(</span><span class="n">krig.est</span><span class="p">,</span><span class="w"> </span><span class="n">krig.est</span><span class="o">@</span><span class="n">data</span><span class="p">)</span><span class="w">
</span><span class="n">levs</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="m">4</span><span class="p">,</span><span class="w"> </span><span class="m">6</span><span class="p">,</span><span class="w"> </span><span class="m">8</span><span class="p">,</span><span class="w"> </span><span class="kc">Inf</span><span class="p">)</span><span class="w">
</span><span class="n">var.levs</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="m">3</span><span class="p">,</span><span class="w"> </span><span class="m">6</span><span class="p">,</span><span class="w"> </span><span class="m">9</span><span class="p">,</span><span class="w"> </span><span class="m">12</span><span class="p">,</span><span class="w"> </span><span class="kc">Inf</span><span class="p">)</span></code></pre></figure> <p>Next, we can create the choropleth maps using the tmap package. Run the following code:</p> <figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">library</span><span class="p">(</span><span class="n">tmap</span><span class="p">)</span><span class="w">
</span><span class="n">krig.map.est</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">tm_shape</span><span class="p">(</span><span class="n">krig.grid</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w">
                </span><span class="n">tm_raster</span><span class="p">(</span><span class="n">col</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">'var1.pred'</span><span class="p">,</span><span class="w"> </span><span class="n">breaks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">levs</span><span class="p">,</span><span class="w"> </span><span class="n">title</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">'Fulmar Density'</span><span class="p">,</span><span class="w"> </span><span class="n">palette</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">'Reds'</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w">
                </span><span class="n">tm_layout</span><span class="p">(</span><span class="n">legend.bg.color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">'white'</span><span class="p">,</span><span class="w"> </span><span class="n">legend.frame</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">TRUE</span><span class="p">)</span><span class="w">

</span><span class="n">krig.map.var</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">tm_shape</span><span class="p">(</span><span class="n">krig.grid</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w">
                </span><span class="n">tm_raster</span><span class="p">(</span><span class="n">col</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">'var1.var'</span><span class="p">,</span><span class="w"> </span><span class="n">breaks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">var.levs</span><span class="p">,</span><span class="w"> </span><span class="n">title</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">'Estimate Variance'</span><span class="p">,</span><span class="w"> </span><span class="n">palette</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">'Reds'</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w">
                </span><span class="n">tm_layout</span><span class="p">(</span><span class="n">legend.bg.color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">'white'</span><span class="p">,</span><span class="w"> </span><span class="n">legend.frame</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">TRUE</span><span class="p">)</span><span class="w">

</span><span class="n">tmap_arrange</span><span class="p">(</span><span class="n">krig.map.est</span><span class="p">,</span><span class="w"> </span><span class="n">krig.map.var</span><span class="p">)</span></code></pre></figure> <p><strong>Figure 2: Kriging estimates of fulmar density (left) and associated variance (right)</strong></p> <div class="row"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/kriging_estimates-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/kriging_estimates-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/kriging_estimates-1400.webp"/> <img src="/assets/img/kriging_estimates.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" title="Kriging estimates of fulmar density and associated variance" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>This example use ordinary kriging. For performing simple kriging with a known mean, you can specify the <code class="language-plaintext highlighter-rouge">beta</code> argument in the <code class="language-plaintext highlighter-rouge">krige()</code> function to the mean, and the simulation will be based on simple kriging. YOu can also sepcified the trend coefficients (including intercept) for universal kriging by providing a vector here.</p> <hr/>]]></content><author><name>Kenan Li</name></author><category term="Tutorial"/><summary type="html"><![CDATA[An introduction to working with kriging in R with examples]]></summary></entry><entry><title type="html">Dr. Kenan Li Recieved the Taylor Fellowship by the Taylor Geospatial Institute</title><link href="https://kenan-li.github.io/blog/2022/Taylor-Fellowships/" rel="alternate" type="text/html" title="Dr. Kenan Li Recieved the Taylor Fellowship by the Taylor Geospatial Institute"/><published>2022-10-17T04:00:00+00:00</published><updated>2022-10-17T04:00:00+00:00</updated><id>https://kenan-li.github.io/blog/2022/Taylor-Fellowships</id><content type="html" xml:base="https://kenan-li.github.io/blog/2022/Taylor-Fellowships/"><![CDATA[<p>The fellowship recognizes Dr. Li’s contributions to the field of geospatial science and his innovative research on developing new tools and methods for analyzing complex geospatial data. As a Taylor Fellow, Dr. Li will have the opportunity to collaborate with other leading geospatial scientists and scholars, and to work on cutting-edge research projects that will advance our understanding of the world around us. The fellowship will also provide support for Dr. Li’s ongoing research and enable him to develop new partnerships and collaborations with other geospatial researchers and organizations.</p>]]></content><author><name></name></author><category term="Award"/><summary type="html"><![CDATA[The fellowship recognizes Dr. Li’s contributions to the field of geospatial science and his innovative research on developing new tools and methods for analyzing complex geospatial data. As a Taylor Fellow, Dr. Li will have the opportunity to collaborate with other leading geospatial scientists and scholars, and to work on cutting-edge research projects that will advance our understanding of the world around us. The fellowship will also provide support for Dr. Li’s ongoing research and enable him to develop new partnerships and collaborations with other geospatial researchers and organizations.]]></summary></entry><entry><title type="html">Research on Disproportionate COVID-19 Mortality in California</title><link href="https://kenan-li.github.io/blog/2021/COVID19-Disparity-California/" rel="alternate" type="text/html" title="Research on Disproportionate COVID-19 Mortality in California"/><published>2021-04-01T00:00:00+00:00</published><updated>2021-04-01T00:00:00+00:00</updated><id>https://kenan-li.github.io/blog/2021/COVID19-Disparity-California</id><content type="html" xml:base="https://kenan-li.github.io/blog/2021/COVID19-Disparity-California/"><![CDATA[<p>Redirecting to another page.</p>]]></content><author><name></name></author><category term="Research"/><summary type="html"><![CDATA[With co-authors Erika Garcia, Ph.D., Sandrah P. Eckel, Ph.D., Zhanghua Chen, Ph.D., and Frank D. Gilliland, Ph.D., Li and the research team published research on the disproportionate mortality impact of COVID-19 on identified racial//ethnic groups.]]></summary></entry><entry><title type="html">Dr. Kenan Li named COVID-19 Geospatial Fellows</title><link href="https://kenan-li.github.io/blog/2020/Geospatial-Fellow/" rel="alternate" type="text/html" title="Dr. Kenan Li named COVID-19 Geospatial Fellows"/><published>2020-10-01T00:00:00+00:00</published><updated>2020-10-01T00:00:00+00:00</updated><id>https://kenan-li.github.io/blog/2020/Geospatial-Fellow</id><content type="html" xml:base="https://kenan-li.github.io/blog/2020/Geospatial-Fellow/"><![CDATA[<p>Redirecting to another page.</p>]]></content><author><name></name></author><category term="Award"/><summary type="html"><![CDATA[The Geospatial Software Institute (GSI) of University of Illinois Urbana Champaign awarded fellowships to Dr. Kenan Li of the Spatial Sciences Institute at the University of Southern California to tackle COVID-19 challenges using geospatial software and advanced capabilities in cyberinfrastructure and data science.]]></summary></entry><entry><title type="html">a post with twitter</title><link href="https://kenan-li.github.io/blog/2020/twitter/" rel="alternate" type="text/html" title="a post with twitter"/><published>2020-09-28T15:12:00+00:00</published><updated>2020-09-28T15:12:00+00:00</updated><id>https://kenan-li.github.io/blog/2020/twitter</id><content type="html" xml:base="https://kenan-li.github.io/blog/2020/twitter/"><![CDATA[<p>A sample blog page that demonstrates the inclusion of Tweets/Timelines/etc.</p> <h1 id="tweet">Tweet</h1> <p>An example of displaying a tweet:</p> <div class="jekyll-twitter-plugin"><blockquote class="twitter-tweet"><p lang="sv" dir="ltr">jekyll-twitter-plugin (1.0.0): A Liquid tag plugin for Jekyll that renders Tweets from Twitter API <a href="http://t.co/m4EIQPM9h4">http://t.co/m4EIQPM9h4</a></p>&mdash; RubyGems (@rubygems) <a href="https://twitter.com/rubygems/status/518821243320287232?ref_src=twsrc%5Etfw">October 5, 2014</a></blockquote> <script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script> </div> <h1 id="timeline">Timeline</h1> <p>An example of pulling from a timeline:</p> <div class="jekyll-twitter-plugin"><a class="twitter-timeline" data-width="500" data-tweet-limit="3" href="https://twitter.com/jekyllrb?ref_src=twsrc%5Etfw">Tweets by jekyllrb</a> <script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script> </div> <h1 id="additional-details">Additional Details</h1> <p>For more details on using the plugin visit: <a href="https://github.com/rob-murray/jekyll-twitter-plugin">jekyll-twitter-plugin</a></p> <figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="c1"># Perform kriging interpolation using the variogram model
</span><span class="w">
</span><span class="n">krig.est</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">krige</span><span class="p">(</span><span class="n">fulmar</span><span class="o">~</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="n">fulmar.spdf</span><span class="p">,</span><span class="w"> </span><span class="n">newdata</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s.grid</span><span class="p">,</span><span class="w"> </span><span class="n">model</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fvgm</span><span class="p">)</span><span class="w">

</span><span class="c1"># Convert the kriging results to a SpatialPixelsDataFrame object
</span><span class="w">
</span><span class="n">krig.grid</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">SpatialPixelsDataFrame</span><span class="p">(</span><span class="n">krig.est</span><span class="p">,</span><span class="w"> </span><span class="n">krig.est</span><span class="o">@</span><span class="n">data</span><span class="p">)</span><span class="w">

</span><span class="c1"># Create a choropleth map of the kriging estimates
</span><span class="w">
</span><span class="n">krig.map.est</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">tm_shape</span><span class="p">(</span><span class="n">krig.grid</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w">
                </span><span class="n">tm_raster</span><span class="p">(</span><span class="n">col</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">'var1.pred'</span><span class="p">,</span><span class="w"> </span><span class="n">breaks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">levs</span><span class="p">,</span><span class="w"> </span><span class="n">title</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">'Fulmar Density'</span><span class="p">,</span><span class="w"> </span><span class="n">palette</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">'Reds'</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w">
                </span><span class="n">tm_layout</span><span class="p">(</span><span class="n">legend.bg.color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">'white'</span><span class="p">,</span><span class="w"> </span><span class="n">legend.frame</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">TRUE</span><span class="p">)</span><span class="w">

</span><span class="c1"># Define breaks for the estimate variance map
</span><span class="w">
</span><span class="n">var.levs</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="m">3</span><span class="p">,</span><span class="w"> </span><span class="m">6</span><span class="p">,</span><span class="w"> </span><span class="m">9</span><span class="p">,</span><span class="w"> </span><span class="m">12</span><span class="p">,</span><span class="w"> </span><span class="kc">Inf</span><span class="p">)</span><span class="w">

</span><span class="c1"># Create a choropleth map of the kriging estimate variance
</span><span class="w">
</span><span class="n">krig.map.var</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">tm_shape</span><span class="p">(</span><span class="n">krig.grid</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w">
                </span><span class="n">tm_raster</span><span class="p">(</span><span class="n">col</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">'var1.var'</span><span class="p">,</span><span class="w"> </span><span class="n">breaks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">var.levs</span><span class="p">,</span><span class="w"> </span><span class="n">title</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">'Estimate Variance'</span><span class="p">,</span><span class="w"> </span><span class="n">palette</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">'Reds'</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w">
                </span><span class="n">tm_layout</span><span class="p">(</span><span class="n">legend.bg.color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">'white'</span><span class="p">,</span><span class="w"> </span><span class="n">legend.frame</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">TRUE</span><span class="p">)</span><span class="w">

</span><span class="c1"># Arrange the two maps side-by-side using tmap_arrange
</span><span class="w">
</span><span class="n">tmap_arrange</span><span class="p">(</span><span class="n">krig.map.est</span><span class="p">,</span><span class="w"> </span><span class="n">krig.map.var</span><span class="p">)</span></code></pre></figure>]]></content><author><name></name></author><category term="sample-posts"/><category term="external-services"/><category term="formatting"/><summary type="html"><![CDATA[an example of a blog post with twitter]]></summary></entry></feed>