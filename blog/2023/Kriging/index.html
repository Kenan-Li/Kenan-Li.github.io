<!DOCTYPE html> <html> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Kriging Interpolation in R | Kenan Li</title> <meta name="author" content="Kenan Li"> <meta name="description" content="An introduction to working with kriging in R with examples"> <meta name="keywords" content="Kenan Li"> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700%7CRoboto+Slab:100,300,400,500,700%7CMaterial+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/assets/img//assets/img/favicon-globe.webp"> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="canonical" href="https://kenan-li.github.io/blog/2023/Kriging/"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js"></script> <script src="/assets/js/dark_mode.js"></script> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script src="/assets/js/distillpub/template.v2.js"></script> <script src="/assets/js/distillpub/transforms.v2.js"></script> <script src="/assets/js/distillpub/overrides.js"></script> </head> <body> <d-front-matter> <script async type="text/json">{
      "title": "Kriging Interpolation in R",
      "description": "An introduction to working with kriging in R with examples",
      "published": "March 8, 2023",
      "authors": [
        {
          "author": "Kenan Li",
          "authorURL": "https://www.slu.edu/public-health-social-justice/faculty/li-kenan.php",
          "affiliations": [
            {
              "name": "Saint Louis University",
              "url": ""
            }
          ]
        }
        
      ],
      "katex": {
        "delimiters": [
          {
            "left": "$",
            "right": "$",
            "display": false
          },
          {
            "left": "$$",
            "right": "$$",
            "display": true
          }
        ]
      }
    }</script> </d-front-matter> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"><span class="font-weight-bold">Kenan </span>Li</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About</a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">Publications</a> </li> <li class="nav-item "> <a class="nav-link" href="/research/">Research</a> </li> <li class="nav-item "> <a class="nav-link" href="/teaching/">Teaching</a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">Software</a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">CV</a> </li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">GRAPH Lab</a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item" href="/background/">Background</a> <div class="dropdown-divider"></div> <a class="dropdown-item" href="/blog/">Blog</a> <div class="dropdown-divider"></div> <a class="dropdown-item" href="/people/">People</a> </div> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="post distill"> <d-title> <h1>Kriging Interpolation in R</h1> <p>An introduction to working with kriging in R with examples</p> </d-title> <d-byline></d-byline> <d-article> <d-contents> <nav class="l-text figcaption"> <h3>Contents</h3> <div><a href="#introduction">Introduction</a></div> <ul> <li><a href="#basic-concepts">Basic Concepts</a></li> <li><a href="#empirical-semivariogram">Empirical Semivariogram</a></li> <li><a href="#modeling-semivariogram">Modeling Semivariogram</a></li> <li><a href="#types-of-kriging">Types of Kriging</a></li> </ul> <div><a href="#implementation">Implementation</a></div> <ul> <li><a href="#fitting-semivariogram">Fitting Semivariogram</a></li> <li><a href="#nugget">Nugget</a></li> <li><a href="#running-kriging">Running Kriging</a></li> </ul> </nav> </d-contents> <h2 id="introduction">Introduction</h2> <p>Spatial interpolation techniques are used to estimate the values of variables at unsampled locations based on the values of the same variable at sampled locations. One of the popular spatial interpolation techniques used in geostatistics is Kriging interpolation. Kriging interpolation is a powerful statistical method that allows one to predict the values of variables at unsampled locations while also accounting for spatial autocorrelation.</p> <p>In this tutorial, we will go through the basic concepts of Kriging interpolation, the types of Kriging, and how to implement the method in R using the <code class="language-plaintext highlighter-rouge">gstat</code> library.</p> <h3 id="basic-concepts">Basic Concepts</h3> <p>Kriging is based on the assumption that the spatial correlation between observations decreases with distance, and that this correlation can be modeled using a mathematical function.</p> <p>The basic idea of kriging is to find a set of weights that can be used to combine the observed values at nearby locations to estimate the value at the target location. The weights are chosen to minimize the variance of the estimation error, subject to the constraint that the estimated value is a linear combination of the observed values.</p> <p>The kriging estimator can be written as:</p> \[\hat{Z}(s_0)=\sum_{i=1}^n \lambda_i Z(s_i) \quad\quad (1)\] <p>where \(\hat{Z}(s_0)\) is the estimated value at the target location s, \(Z(s_i)\) is the observed value at location i, \(\lambda_i\) is the weight assigned to the observed value at location i, and \(n\) is the number of observed locations.</p> <p>The weights are typically chosen to minimize the estimation variance \(\sigma^2\), which is given by:</p> \[min\ \ \ \sigma^2 = E \left[ Z(s_0)-\sum_{i=1}^n \lambda_i Z(s_i) \right] \quad\quad (2)\] <p>The weights \(\lambda_i\) are chosen to minimize the estimation variance subject to the constraint that they sum to one:</p> \[\sum_{i=1}^n \lambda_i = 1 \quad\quad (3)\] <h3 id="empirical-semivariogram">Empirical Semivariogram</h3> <p>Semivariogram is a tool commonly used in geostatistics to analyze spatial autocorrelation in data. It is a measure of the dissimilarity between pairs of values at different locations within a dataset. Semivariogram can provide insights into the spatial structure of data, which can be useful in predicting values at unobserved locations through kriging interpolation.</p> <p>The empirical semivariogram is defined as the average squared difference between pairs of observations separated by a certain distance or lag, and is expressed mathematically as:</p> \[\gamma(h) = \frac{1}{2N(h)} \sum_{i=1}^{n} \sum_{|s_j-s_i| &lt; h} [Z(s_i)-Z(s_j)]^2 \quad\quad (4)\] <p>where \(\gamma(h)\) is the semivariance for a lag distance \(h\), \(N(h)\) is the number of pairs of observations separated by the distance \(h\), and \(Z(s_i)\) is the value of the variable at location \(s_i\).</p> <p>The empirical semivariogram is typically plotted as a function of lag distance, which shows how the dissimilarity between pairs of observations changes as the distance between them increases. The shape of the semivariogram curve can provide insights into the spatial structure of the data.</p> <p>In kriging interpolation, the semivariogram is used to estimate the spatial autocorrelation of the variable being modeled. The semivariogram model is then used to estimate the variance of the estimation errors \(\sigma^2\) at unobserved locations, which is used to calculate the kriging weights. The kriging weights are then used to calculate the estimated value at the unobserved location.</p> <h3 id="modeling-semivariogram">Modeling Semivariogram</h3> <p>Empirical semivariogram does not assume under underlying spatial structure of the data. In order to use semivariogram for spatial prediction through kriging interpolation or other geostatistical techniques, it is necessary to model the spatial autocorrelation structure of the data using a theoretical semivariogram model.</p> <p>These models typically have a covariance function that describes the expected correlation between pairs of observations at different distances, based on assumptions about the underlying spatial structure of the data. Table 1 listed some commonly used covariance functions.</p> <p><strong>Table 1: Some Semivariogram Functions</strong> <d-footnote>$^*$ where $C(h)$ is the semivariance at lag distance $h$, $c$ is the sill (maximum semivariance), $a$ is the range (distance at which the semivariance reaches the sill), $\nu$ is a smoothness parameter, $\Gamma(\nu)$ is the gamma function, and $K_\nu$ is the modified Bessel function of the second kind of order $\nu$.</d-footnote></p> <table> <thead> <tr> <th>Name</th> <th style="text-align: center">Function From</th> </tr> </thead> <tbody> <tr> <td>Exponential</td> <td style="text-align: center">\(C(h) = c \left[1 - \exp\left(-\frac{h}{a}\right)\right]\)</td> </tr> <tr> <td>Gaussian</td> <td style="text-align: center">\(C(h) = c \left[1 - \exp\left(-\frac{h^2}{a^2}\right)\right]\)</td> </tr> <tr> <td>Matérn</td> <td style="text-align: center">\(C(h) = \frac{\sigma^2}{\Gamma(\nu) 2^{\nu-1}} \left(\frac{\sqrt{2\nu}}{a}h\right)^\nu K_\nu\left(\frac{\sqrt{2\nu}}{a}h\right)\)</td> </tr> <tr> <td>Spherical</td> <td style="text-align: center">\(C(h) = c \left[1.5 \frac{h}{a} - 0.5 \left(\frac{h}{a}\right)^3\right] \quad \text{for } h \le a\)</td> </tr> </tbody> </table> <p>Fitting a semivariogram model to the empirical semivariogram involves estimating the parameters of the model, such as the sill, range, and smoothness parameter, that best describe the spatial autocorrelation structure of the data. This is typically done through solving a least-squares problem, where the goal is to minimize the sum of the squared differences between the empirical semivariogram and the semivariogram model predictions at different lag distances.</p> <p>The following steps outline the basic procedure for fitting a semivariogram model to the empirical semivariogram:</p> <ol> <li> <p>Calculate the empirical semivariogram for the dataset using Equation 4.</p> </li> <li> <p>Choose a covariance function that is appropriate for the spatial autocorrelation structure of the data. This can be based on visual inspection of the empirical semivariogram, or on prior knowledge of the data.</p> </li> <li> <p>Estimate the parameters of the semivariogram model. This involves finding the values of the model parameters that minimize the sum of the squared differences between the predicted semivariance values from the model and the observed semivariance values from the empirical semivariogram.</p> </li> <li> <p>Evaluate the goodness of fit of the semivariogram model to the empirical semivariogram. This can be done using various statistical measures, such as the coefficient of determination (\(R^2\)), the root mean squared error (RMSE), or the Akaike information criterion (AIC).</p> </li> <li> <p>Use the fitted semivariogram model to make spatial predictions through kriging interpolation or other geostatistical techniques.</p> </li> </ol> <p>It is important to note that the choice of semivariogram model and the method used for parameter estimation can have a significant impact on the accuracy and reliability of the spatial predictions. It is therefore important to carefully evaluate the performance of different semivariogram models and parameter estimation methods before making spatial predictions.</p> <p>It is also important to note that the covariance function and the empirical semivariogram are two related concepts in geostatistics, but they are not the same thing. The covariance function describes the relationship between two spatial locations in terms of their similarity or dissimilarity. It is a mathematical function that specifies the covariance or correlation between two locations as a function of their distance or lag. The covariance function is typically used in kriging to estimate the unknown value of a variable at an unsampled location as a linear combination of the observed values at nearby locations, weighted by their covariance with the unsampled location.</p> <p>The semivariogram, on the other hand, is a measure of spatial dependence or autocorrelation in a variable. It is defined as half the variance of the differences between pairs of values separated by a certain lag or distance. The semivariogram is a graphical representation of the spatial structure of the variable, showing how the similarity between values decreases with increasing distance or lag. The semivariogram is often used in geostatistics to estimate the covariance function, by fitting a model to the empirical semivariogram.</p> <h3 id="types-of-kriging">Types of kriging</h3> <p>There are various types of kriging, including ordinary kriging, simple kriging, and universal kriging, which differ in their assumptions about the mean of the unknown variable and the spatial covariance function.</p> <ol> <li> <p>Ordinary kriging:</p> <p>Ordinary kriging assumes that the mean of the unknown variable \(\mu\) is unknown and that the covariance between the variable at any two locations depends only on the distance between the locations (intrisical stationarity). The model assumption can be written as:</p> \[Z(s) = \mu + \delta(s) \quad\quad (5)\] <p>where \(\delta(s)\) is a zero mean stochastic term, and \(\mu\) is the unknown mean of the variable. For intrinsically stationary process, Equation 2 can be written as (a detailed proof can be found here<d-cite key="christoffersson2018"></d-cite>):</p> \[\sigma^2 = 2\sum_{i=1}^{n}\lambda_i\gamma(s_0, s_i) - \sum_{i=1}^{n}\sum_{j=1}^{n}\lambda_i\lambda_j\gamma(s_i, s_j) \quad\quad (6)\] <p>Using matrix notation and covariance function \(C(s_i, s_j)\) to model semivariogram \(\gamma(s_i, s_j)\), the kriging system of equations for ordinary kriging can be written as:</p> \[\begin{bmatrix}C(s_1, s_1) &amp; C(s_1, s_2) &amp; \cdots &amp; C(s_1, s_n) &amp; 1\\C(s_2, s_1) &amp; C(s_2, s_2) &amp; \cdots &amp; C(s_2, s_n) &amp; 1\\\vdots &amp; \vdots&amp; \ddots &amp; \vdots &amp; \vdots\\C(s_n, s_1) &amp; C(s_n, s_2) &amp; \cdots &amp; C(s_n, s_n) &amp; 1\\1 &amp; 1 &amp; \cdots &amp; 1 &amp; 0\end{bmatrix}\begin{bmatrix}\lambda_1\\\lambda_2\\\vdots\\\lambda_n\\\hat{\mu}\end{bmatrix} = \begin{bmatrix}C(s_1, s_0)\\C(s_2, s_0)\\\vdots\\C(s_n, s_0)\\1\end{bmatrix}\] <p>where \(\hat{\mu}\) is the estimated mean of the variable, and the additional row and column of 1’s correspond to the constraint that the weights sum to 1 and the assumption that the mean of the variable is unknown. The weights \(\lambda_i\) are chosen to minimize the estimation variance subject to the constraint that they sum to one.</p> </li> <li> <p>Simple kriging:</p> <p>Simple kriging assumes that the mean of the unknown variable is known and that the covariance between the variable at any two locations depends only on the distance between the locations. The kriging system of equations for simple kriging can be written as:</p> \[\begin{bmatrix}C(s_1, s_1) &amp; C(s_1, s_2) &amp; \cdots &amp; C(s_1, s_n)\\C(s_2, s_1) &amp; C(s_2, s_2) &amp; \cdots &amp; C(s_2, s_n)\\\vdots &amp; \vdots&amp; \ddots &amp; \vdots\\C(s_n, s_1) &amp; C(s_n, s_2) &amp; \cdots &amp; C(s_n, s_n)\end{bmatrix}\begin{bmatrix}\lambda_1\\\lambda_2\\\vdots\\\lambda_n\end{bmatrix} = \begin{bmatrix}C(s_1, s_0)-\mu\\C(s_2, s_0)-\mu\\\vdots\\C(s_n, s_0)-\mu\end{bmatrix}\] <p>where \(\mu\) is the known mean of the variable and the weights \(\lambda\) are chosen to minimize the estimation variance subject to the constraint that they sum to one.</p> </li> <li> <p>Universal kriging:</p> <p>Universal kriging assumes that the mean of the unknown variable can be modeled using a known function of the spatial coordinates and/or covariates (drift or trend term), such as a linear or quadratic function. The covariance between the variable at any two locations depends on depends only on the distance between the locations. The universal kriging estimator at an unsampled location \(s\) is given by:</p> \[Z(s) = \sum_{j=1}^{p} \beta_j v_j(s) + \delta(s) \quad\quad (7)\] <p>where \(\beta_j\) are the coefficients of the drift term in the regression model, and \(v_j(s)\) is the value of the $j$th covariate at location \(s\).</p> <p>The kriging system of equations for universal kriging can be written as:</p> </li> </ol> \[\begin{bmatrix} C(s_1, s_1) &amp; \cdots &amp; C(s_1, s_n) &amp; v_1(s_1) &amp; \cdots &amp; v_p(s_1) \\ \vdots &amp; \ddots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ C(s_n, s_1) &amp; \cdots &amp; C(s_n, s_n) &amp; v_1(s_n) &amp; \cdots &amp; v_p(s_n) \\ v_1(s_1) &amp; \cdots &amp; v_1(s_n) &amp; 0 &amp; \cdots &amp; 0 \\ \vdots &amp; \ddots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ v_p(s_1) &amp; \cdots &amp; v_p(s_n) &amp; 0 &amp; \cdots &amp; 0 \end{bmatrix} \begin{bmatrix} \lambda_1 \\ \vdots \\ \lambda_n \\ -\beta_1 \\ \vdots \\ -\beta_p \end{bmatrix} = \begin{bmatrix} C(s_1,s_0) \\ \vdots \\ C(s_n,s_0) \\ v_1(s_0) \\ \vdots \\ v_p(s_0) \end{bmatrix}\] <p>where \(C(s_i, s_j)\) represents the covariance between locations \(s_i\) and \(s_j\) in the presence of a drift term, \(C(s_i,s_0)\) represents the semivariance between the unsampled location and location \(s_i\), \(\lambda_i\) represents the kriging weights for each sampled location, \(\mu\) represents the kriging estimate of the mean value, \(\beta_j\) represents the coefficients of the drift term in the regression model, and \(v_j(s_i)\) represents the value of the \(j\)th covariate at location \(s_i\).</p> <hr> <h2 id="implementation">Implementation</h2> <h3 id="fitting-semivariogram">Fitting Semivariogram</h3> <p>The implementation example used in this task is based on the book “An Introduction to R for Spatial Analysis and Mapping” by Brunsdon and Comber<d-cite key="brunsdoncomber2018"></d-cite>. Before following the example, you must install the <code class="language-plaintext highlighter-rouge">gstat</code> R library in your R environment. The <code class="language-plaintext highlighter-rouge">gstat</code> library is designed for geostatistical modeling and spatial data analysis in R, providing a wide range of tools for spatial data exploration, variogram modeling, kriging, and spatial prediction.</p> <p>We will be using the <code class="language-plaintext highlighter-rouge">fulmar</code> dataset included in the gstat library to practice kriging interpolation. The <code class="language-plaintext highlighter-rouge">fulmar</code> dataset contains airborne counts of the sea bird Fulmaris glacialis during August and September of 1998 and 1999 over the Dutch part of the North Sea. The counts are taken along transects corresponding to flight paths of the observation aircraft and are transformed to densities by dividing counts by the area of observation, which is \(0.5 km^2\).</p> <p>The codes below plots the kriging semivariogram of the <code class="language-plaintext highlighter-rouge">fulmar</code> dataset:</p> <figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="c1"># Load the gstat library</span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="n">gstat</span><span class="p">)</span><span class="w">

</span><span class="c1"># Load the fulmar dataset from the gstat library</span><span class="w">
</span><span class="n">data</span><span class="p">(</span><span class="s2">"fulmar"</span><span class="p">)</span><span class="w">

</span><span class="c1"># Create a SpatialPointsDataFrame object from the fulmar dataset</span><span class="w">
</span><span class="c1"># The cbind function combines the x and y coordinates into a matrix, which is used to create the SpatialPointsDataFrame</span><span class="w">
</span><span class="n">fulmar.spdf</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">SpatialPointsDataFrame</span><span class="p">(</span><span class="n">cbind</span><span class="p">(</span><span class="n">fulmar</span><span class="o">$</span><span class="n">x</span><span class="p">,</span><span class="n">fulmar</span><span class="o">$</span><span class="n">y</span><span class="p">),</span><span class="w"> </span><span class="n">fulmar</span><span class="p">)</span><span class="w">

</span><span class="c1"># Calculate the empirical variogram of the 'fulmar' variable in the fulmar.spdf dataset</span><span class="w">
</span><span class="c1"># The 'fulmar~1' formula specifies the variable to be analyzed and '1' indicates that there are no covariates</span><span class="w">
</span><span class="c1"># The 'boundaries' argument sets the distance lags for the variogram calculation</span><span class="w">
</span><span class="n">evgm</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">variogram</span><span class="p">(</span><span class="n">fulmar</span><span class="o">~</span><span class="m">1</span><span class="p">,</span><span class="n">fulmar.spdf</span><span class="p">,</span><span class="w"> </span><span class="n">boundaries</span><span class="o">=</span><span class="n">seq</span><span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="m">250000</span><span class="p">,</span><span class="n">l</span><span class="o">=</span><span class="m">51</span><span class="p">))</span><span class="w">

</span><span class="c1"># Fit a variogram model to the experimental variogram</span><span class="w">
</span><span class="c1"># The 'vgm' function specifies the type of variogram model to be used</span><span class="w">
</span><span class="c1"># Here, a Matérn model with a sill of 3, a range of 100000 and a nugget of 1 is used</span><span class="w">
</span><span class="n">fvgm</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">fit.variogram</span><span class="p">(</span><span class="n">evgm</span><span class="p">,</span><span class="n">vgm</span><span class="p">(</span><span class="m">3</span><span class="p">,</span><span class="s2">"Mat"</span><span class="p">,</span><span class="m">100000</span><span class="p">,</span><span class="m">1</span><span class="p">))</span><span class="w">

</span><span class="c1"># Plot the experimental variogram with the fitted variogram model</span><span class="w">
</span><span class="c1"># The 'model' argument specifies the fitted variogram model to be plotted</span><span class="w">
</span><span class="n">plot</span><span class="p">(</span><span class="n">evgm</span><span class="p">,</span><span class="n">model</span><span class="o">=</span><span class="n">fvgm</span><span class="p">)</span></code></pre></figure> <p>The <code class="language-plaintext highlighter-rouge">variogram()</code> function computes the empirical variogram, and takes the following key arguments:</p> <ul> <li> <code class="language-plaintext highlighter-rouge">formula</code>: A formula specifying the variables to be used in the calculation of the variogram. The formula takes the form <code class="language-plaintext highlighter-rouge">response</code> ~ <code class="language-plaintext highlighter-rouge">predictor</code>, where <code class="language-plaintext highlighter-rouge">response</code> is the variable to be analyzed and <code class="language-plaintext highlighter-rouge">predictor</code> is an optional covariate or drift term. The covariate can be a numeric or factor variable, and the drift term can be specified as 1 for <code class="language-plaintext highlighter-rouge">ordinary kriging</code>.</li> <li> <code class="language-plaintext highlighter-rouge">data</code>: A spatial data object containing the variables specified in the formula argument.</li> <li> <code class="language-plaintext highlighter-rouge">width</code>: The maximum lag distance between pairs of sample locations. If not specified, the function will determine the maximum lag distance based on the data.</li> </ul> <p><strong>Figure 1: Matérn Semivariogram of Fulmar Counts in the North Sea</strong></p> <div class="row"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/fulmar_variogram-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/fulmar_variogram-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/fulmar_variogram-1400.webp"></source> <img src="/assets/img/fulmar_variogram.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" title="Matérn Semivariogram of Fulmar Counts in the North Sea" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <h3 id="nugget">Nugget</h3> <p>In <code class="language-plaintext highlighter-rouge">vgm(3,"Mat",100000,1)</code>, the <code class="language-plaintext highlighter-rouge">nugget</code> argumaent refers to the intercept of the variogram at zero distance or lag. It represents the spatial variability that cannot be explained by the spatial autocorrelation in the data, such as measurement error or microscale variation.</p> <p>The nugget effect is an important concept in variogram modeling because it affects the shape of the variogram and the spatial prediction derived from it. A large nugget effect indicates that there is a high degree of spatial variability at small distances or lags, which can lead to difficulties in spatial interpolation and prediction. On the other hand, a small nugget effect indicates that the spatial variability is primarily driven by spatial autocorrelation, making it easier to predict the value of the variable at unsampled locations.</p> <p>Variogram models that account for the nugget effect can be used to estimate the spatial correlation structure of the data and to make predictions at unsampled locations based on that structure. Different types of variogram models, such as exponential, Gaussian, and Matérn, incorporate the nugget effect in different ways and may be more appropriate for certain types of data or spatial structures.</p> <h3 id="running-kriging">Running Kriging</h3> <p>Now we can perform kriging interpolation using the variogram model. Run the following code:</p> <figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">s.grid</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">spsample</span><span class="p">(</span><span class="n">fulmar.spdf</span><span class="p">,</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"regular"</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">6000</span><span class="p">)</span><span class="w">
</span><span class="n">krig.est</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">krige</span><span class="p">(</span><span class="n">fulmar</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="n">fulmar.spdf</span><span class="p">,</span><span class="w"> </span><span class="n">newdata</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s.grid</span><span class="p">,</span><span class="w"> </span><span class="n">model</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fvgm</span><span class="p">)</span></code></pre></figure> <p>This code creates a variogram model from the <code class="language-plaintext highlighter-rouge">fulmar</code> data and uses it to perform kriging interpolation on the <code class="language-plaintext highlighter-rouge">s.grid</code> object. The points at which estimates are made are supplied in <code class="language-plaintext highlighter-rouge">s.grid</code>. The <code class="language-plaintext highlighter-rouge">krige()</code> function returns a <code class="language-plaintext highlighter-rouge">SpatialPointsDataFrame</code> object containing the kriging estimates.</p> <p>To create a choropleth map of the kriging estimates, we need to convert the kriging results to a <code class="language-plaintext highlighter-rouge">SpatialPixelsDataFrame</code> object and define a color palette for the map. We also need to define break values for the estimate variance map. Run the following code:</p> <figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">krig.grid</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">SpatialPixelsDataFrame</span><span class="p">(</span><span class="n">krig.est</span><span class="p">,</span><span class="w"> </span><span class="n">krig.est</span><span class="o">@</span><span class="n">data</span><span class="p">)</span><span class="w">
</span><span class="n">levs</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="m">4</span><span class="p">,</span><span class="w"> </span><span class="m">6</span><span class="p">,</span><span class="w"> </span><span class="m">8</span><span class="p">,</span><span class="w"> </span><span class="kc">Inf</span><span class="p">)</span><span class="w">
</span><span class="n">var.levs</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="m">3</span><span class="p">,</span><span class="w"> </span><span class="m">6</span><span class="p">,</span><span class="w"> </span><span class="m">9</span><span class="p">,</span><span class="w"> </span><span class="m">12</span><span class="p">,</span><span class="w"> </span><span class="kc">Inf</span><span class="p">)</span></code></pre></figure> <p>Next, we can create the choropleth maps using the tmap package. Run the following code:</p> <figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">library</span><span class="p">(</span><span class="n">tmap</span><span class="p">)</span><span class="w">
</span><span class="n">krig.map.est</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">tm_shape</span><span class="p">(</span><span class="n">krig.grid</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w">
                </span><span class="n">tm_raster</span><span class="p">(</span><span class="n">col</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">'var1.pred'</span><span class="p">,</span><span class="w"> </span><span class="n">breaks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">levs</span><span class="p">,</span><span class="w"> </span><span class="n">title</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">'Fulmar Density'</span><span class="p">,</span><span class="w"> </span><span class="n">palette</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">'Reds'</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w">
                </span><span class="n">tm_layout</span><span class="p">(</span><span class="n">legend.bg.color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">'white'</span><span class="p">,</span><span class="w"> </span><span class="n">legend.frame</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">TRUE</span><span class="p">)</span><span class="w">

</span><span class="n">krig.map.var</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">tm_shape</span><span class="p">(</span><span class="n">krig.grid</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w">
                </span><span class="n">tm_raster</span><span class="p">(</span><span class="n">col</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">'var1.var'</span><span class="p">,</span><span class="w"> </span><span class="n">breaks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">var.levs</span><span class="p">,</span><span class="w"> </span><span class="n">title</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">'Estimate Variance'</span><span class="p">,</span><span class="w"> </span><span class="n">palette</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">'Reds'</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w">
                </span><span class="n">tm_layout</span><span class="p">(</span><span class="n">legend.bg.color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">'white'</span><span class="p">,</span><span class="w"> </span><span class="n">legend.frame</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">TRUE</span><span class="p">)</span><span class="w">

</span><span class="n">tmap_arrange</span><span class="p">(</span><span class="n">krig.map.est</span><span class="p">,</span><span class="w"> </span><span class="n">krig.map.var</span><span class="p">)</span></code></pre></figure> <p><strong>Figure 2: Kriging estimates of fulmar density (left) and associated variance (right)</strong></p> <div class="row"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/kriging_estimates-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/kriging_estimates-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/kriging_estimates-1400.webp"></source> <img src="/assets/img/kriging_estimates.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" title="Kriging estimates of fulmar density and associated variance" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <p>This example use ordinary kriging. For performing simple kriging with a known mean, you can specify the <code class="language-plaintext highlighter-rouge">beta</code> argument in the <code class="language-plaintext highlighter-rouge">krige()</code> function to the mean, and the simulation will be based on simple kriging. YOu can also sepcified the trend coefficients (including intercept) for universal kriging by providing a vector here.</p> <hr> </d-article> <d-appendix> <d-footnote-list></d-footnote-list> <d-citation-list></d-citation-list> </d-appendix> <d-bibliography src="/assets/bibliography/2018-12-22-distill.bib"></d-bibliography><div id="giscus_thread" style="max-width: 800px; margin: 0 auto;"> <script>let giscusTheme=localStorage.getItem("theme"),giscusAttributes={src:"https://giscus.app/client.js","data-repo":"Kenan-Li/personal_website_kl","data-repo-id":"MDEwOlJlcG9zaXRvcnk2MDAyNDM2NQ==","data-category":"Comments","data-category-id":"DIC_kwDOA5PmLc4CTBt6","data-mapping":"title","data-strict":"1","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":giscusTheme,"data-lang":"en",crossorigin:"anonymous",async:""},giscusScript=document.createElement("script");Object.entries(giscusAttributes).forEach(([t,e])=>giscusScript.setAttribute(t,e)),document.getElementById("giscus_thread").appendChild(giscusScript);</script> <noscript>Please enable JavaScript to view the <a href="http://giscus.app/?ref_noscript" rel="external nofollow noopener" target="_blank">comments powered by giscus.</a> </noscript> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2023 Kenan Li. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>