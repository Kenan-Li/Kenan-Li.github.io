<!DOCTYPE html> <html> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Spatial Randomness and Autocorrelation | Kenan Li</title> <meta name="author" content="Kenan Li"> <meta name="description" content="An introduction to computing spatial Randomness and autocorrelation in R with examples"> <meta name="keywords" content="Kenan Li"> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700%7CRoboto+Slab:100,300,400,500,700%7CMaterial+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/assets/img//assets/img/favicon-globe.webp"> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="canonical" href="https://kenan-li.github.io/blog/2023/Spatial-Autocorrelation/"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js"></script> <script src="/assets/js/dark_mode.js"></script> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script src="/assets/js/distillpub/template.v2.js"></script> <script src="/assets/js/distillpub/transforms.v2.js"></script> <script src="/assets/js/distillpub/overrides.js"></script> </head> <body> <d-front-matter> <script async type="text/json">{
      "title": "Spatial Randomness and Autocorrelation",
      "description": "An introduction to computing spatial Randomness and autocorrelation in R with examples",
      "published": "April 3, 2023",
      "authors": [
        {
          "author": "Kenan Li",
          "authorURL": "https://www.slu.edu/public-health-social-justice/faculty/li-kenan.php",
          "affiliations": [
            {
              "name": "Saint Louis University",
              "url": ""
            }
          ]
        }
        
      ],
      "katex": {
        "delimiters": [
          {
            "left": "$",
            "right": "$",
            "display": false
          },
          {
            "left": "$$",
            "right": "$$",
            "display": true
          }
        ]
      }
    }</script> </d-front-matter> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"><span class="font-weight-bold">Kenan </span>Li</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About</a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">Publications</a> </li> <li class="nav-item "> <a class="nav-link" href="/research/">Research</a> </li> <li class="nav-item "> <a class="nav-link" href="/teaching/">Teaching</a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">Software</a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">CV</a> </li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">GRAPH Lab</a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item" href="/background/">Background</a> <div class="dropdown-divider"></div> <a class="dropdown-item" href="/blog/">Blog</a> <div class="dropdown-divider"></div> <a class="dropdown-item" href="/people/">People</a> </div> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="post distill"> <d-title> <h1>Spatial Randomness and Autocorrelation</h1> <p>An introduction to computing spatial Randomness and autocorrelation in R with examples</p> </d-title> <d-byline></d-byline> <d-article> <d-contents> <nav class="l-text figcaption"> <h3>Contents</h3> <div><a href="#background">Background</a></div> <ul> <li><a href="#definitions">Definitions</a></li> <li><a href="#differences">Differences</a></li> <li><a href="#complete-spatial-randomness-csr-measurements">Complete Spatial Randomness (CSR) measurements</a></li> <li><a href="#spatial-autocorrelation-measurements">Spatial autocorrelation measurements</a></li> </ul> <div><a href="#examples-of-csr">Examples of CSR</a></div> <ul> <li><a href="#using-k-function-and-l-function">Using K function and L function</a></li> <li><a href="#using-g-function">Using G function</a></li> </ul> <div><a href="#example-of-moran-s-i">Example of Moran's I</a></div> <ul> <li><a href="#the-pennsylvania-lung-cancer-data">The Pennsylvania Lung Cancer Data</a></li> <li><a href="#visual-explotration-of-autocorrelation">Visual Explotration of Autocorrelation</a></li> <li><a href="#neighbours-and-lagged-mean-plots">Neighbours and Lagged Mean Plots</a></li> <li><a href="#caculation-of-moran-i">Caculation of Moran'I</a></li> </ul> </nav> </d-contents> <h2 id="background">Background</h2> <p>Spatial randomness and spatial autocorrelation are two concepts related to the distribution of data in space. They describe different aspects of spatial data and have different implications for the analysis of spatial patterns.</p> <h3 id="definitions">Definitions</h3> <p><code class="language-plaintext highlighter-rouge">Spatial randomness</code>: Spatial randomness refers to a situation where the location of events or features in space does not follow any discernible pattern. In other words, the events or features are randomly distributed across the study area, and their locations are not influenced by the locations of other events or features. Complete spatial randomness (CSR) is often used as a null hypothesis in spatial analyses, which assumes that the observed pattern is random and not influenced by any underlying spatial process.</p> <p><code class="language-plaintext highlighter-rouge">Spatial autocorrelation</code>: Spatial autocorrelation refers to the correlation between a variable at one location and the same variable at neighboring locations. It measures the degree to which nearby locations exhibit similar (or dissimilar) values. Positive spatial autocorrelation means that similar values are clustered together, while negative spatial autocorrelation means that dissimilar values are closer together. If there is no spatial autocorrelation, the values are randomly distributed across the study area.</p> <h3 id="differences">Differences</h3> <ul> <li> <p>Spatial randomness pertains to the absence of any discernible pattern in the distribution of events or features in space, while spatial autocorrelation measures the correlation between a variable at one location and the same variable at neighboring locations.</p> </li> <li> <p>Spatial randomness is often used as a null hypothesis in spatial analysis, while spatial autocorrelation is an inherent property of the data that can reveal underlying spatial processes or structures.</p> </li> </ul> <p>In summary, spatial randomness and spatial autocorrelation describe different aspects of spatial data. Spatial randomness relates to the distribution of events or features, while spatial autocorrelation quantifies the degree of similarity between values at nearby locations. These concepts are essential for understanding and analyzing spatial patterns in various types of spatial data.</p> <h3 id="complete-spatial-randomness-csr-measurements">Complete Spatial Randomness (CSR) measurements</h3> <ol> <li> <p><code class="language-plaintext highlighter-rouge">Ripley's K function</code>: The K function is used to assess CSR in point patterns. It calculates the expected number of points within a given distance ‘r’ of an arbitrary point, divided by the overall point density. If the observed K function is close to the theoretical K function under CSR, the point pattern is consistent with spatial randomness.</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">L function</code>: The L function is a derived function from Ripley’s K function, which is used to assess Complete Spatial Randomness (CSR) in point pattern data. The L function is designed to provide a linearized visualization of the K function, making it easier to interpret the results.</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">Nearest Neighbor Distance Distribution function (G function)</code>: The G function is another measure used to assess CSR in point patterns. It estimates the cumulative distribution function of the nearest neighbor distances in a point pattern. If the observed G function is close to the theoretical G function under CSR, the point pattern is consistent with spatial randomness.</p> </li> </ol> <h3 id="spatial-autocorrelation-measurements">Spatial autocorrelation measurements</h3> <ol> <li> <p><code class="language-plaintext highlighter-rouge">Moran's I</code> Moran’s I is a global measure of spatial autocorrelation for continuous or areal data. It measures the correlation between a variable at one location and the same variable at neighboring locations. Moran’s I values range from -1 (negative spatial autocorrelation) to 1 (positive spatial autocorrelation), with values close to 0 indicating no spatial autocorrelation.</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">Geary's C</code>: Geary’s C is another global measure of spatial autocorrelation for continuous or areal data. It is based on the difference between values at neighboring locations. Geary’s C values range from 0 (positive spatial autocorrelation) to 2 (negative spatial autocorrelation), with values close to 1 indicating no spatial autocorrelation.</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">Local Indicators of Spatial Association (LISA)</code>: LISA is a set of local measures of spatial autocorrelation for continuous or areal data. It identifies local clusters of high or low values and spatial outliers. Common LISA statistics include Local Moran’s I, Local Geary’s C, and Local Getis-Ord G*.</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">Semivariogram</code>: The semivariogram is a measure of spatial autocorrelation for continuous data that quantifies the similarity between pairs of data points as a function of the distance between them. It is used to model spatial dependence and is the basis for geostatistical techniques like kriging.</p> </li> </ol> <hr> <h2 id="examples-of-csr">Examples of CSR</h2> <h3 id="using-k-function-and-l-fuction">Using K Function and L Fuction</h3> <p>The K function is defined by:</p> \[K(r) = λ^{-1} * E[N(r)] \quad\quad (1)\] <p>where λ is the point density (total number of points divided by the study area), E[N(r)] is the expected number of points within distance ‘r’ from an arbitrary point, and r is the distance.</p> <p>When analyzing point patterns to test for CSR, we often assume an underlying Poisson process.The theoretical K function under CSR for a Poisson process is:</p> \[K(r) = \pi * r^2 \quad\quad (2)\] <ul> <li> <p>If the observed K function is close to the theoretical K function (Poisson process), the point pattern is consistent with CSR.</p> </li> <li> <p>If the observed K function lies above the theoretical K function, the point pattern exhibits clustering.</p> </li> <li> <p>If the observed K function lies below the theoretical K function, the point pattern exhibits regularity or dispersion.</p> </li> </ul> <p>By comparing the observed K function with the theoretical K function under the CSR assumption, you can assess whether the spatial distribution of points is consistent with a Poisson process or if there is evidence of clustering or regularity in the data.</p> <p>When working with a sample of data points, the K function will not usually be known, and we will use the Edge-corrected estimation of K function (Ripley’s K function):</p> \[K(r) = \left(1 / λ\right) * \sum_{i=1}^{n}\left[\sum_{j\neq i}(I(||u_i - u_j|| &lt;= r) / w(||u_i - u_j||))\right] \quad\quad (3)\] <p>where:</p> <ul> <li>K(r) is the estimated K function at distance r,</li> <li>λ is the point density (total number of points divided by the study area),</li> <li>n is the total number of points in the point pattern,</li> <li>$u_i$ and $u_j$ are the spatial coordinates of points i and j, respectively,</li> <li>$||u_i - u_j||$ is the Euclidean distance between points i and j,</li> <li>I(·) is an indicator function that equals 1 if the condition inside the brackets is true and 0 otherwise,</li> <li>w(·) is an edge-correction function that accounts for the fact that points near the boundary of the study area have fewer neighbors.</li> </ul> <p>The edge correction function is an essential component of Ripley’s K function estimation. It is needed to account for the boundary effects that arise when analyzing point patterns within a finite study area. Points near the boundary of the study area have fewer neighbors than points located in the interior, which can lead to biased estimations of the K function. Note that there are different edge-correction methods available, such as the isotropic correction, which is the default method in Ripley’s K function estimation. The isotropic correction is given by:</p> \[w(||u_i - u_j||) = 1/(1 - (π * r^2 / A)) \quad\quad (4)\] <p>The L function is derived from the K function and is used to provide a linearized interpretation of the results from the K function. The L function is defined as:</p> \[L(r) = \sqrt{\frac{K(r)}{\pi}} \quad\quad (5)\] <p>Given a Poisson process, we can substitute Equation 2 into the L function to get the L function under CSR:</p> \[L_{CSR}(r) = \sqrt{\frac{\pi r^2}{\pi}} = r \quad\quad (6)\] <p>To simplify the interpretation of the L function, we often plot the difference between the L function and the distance r:</p> \[L(r) - r \quad\quad (7)\] <p>The relationship between the K function and the L function can be summarized as follows:</p> <ul> <li> <p>The L function is derived from the K function to provide a linearized interpretation of the spatial pattern analysis.</p> </li> <li> <p>The L function under CSR is equal to the distance r, which simplifies the interpretation of the results.</p> </li> <li> <p>By plotting the difference between the L function and the distance r, we can easily identify deviations from CSR, clustering, or dispersion.</p> </li> </ul> <p>To interpret the L(r) - r plot:</p> <ul> <li> <p>If the L(r) - r plot is close to the horizontal axis (L(r) - r ≈ 0), it suggests Complete Spatial Randomness (CSR).</p> </li> <li> <p>If the L(r) - r plot lies above the horizontal axis (L(r) - r &gt; 0), it indicates clustering.</p> </li> <li> <p>If the L(r) - r plot lies below the horizontal axis (L(r) - r &lt; 0), it indicates regularity or dispersion.</p> </li> </ul> <p>In summary, the L function is derived from the K function to provide a more straightforward interpretation of spatial patterns in point data. By comparing the L function plot with the expected L function under CSR (L(r) = r), we can assess the degree of clustering or regularity in the data.</p> <p>In the following example, we will use Ripley’s K function to analyze the <code class="language-plaintext highlighter-rouge">bramblecanes</code> dataset from the <code class="language-plaintext highlighter-rouge">spatstat</code>library in R. First, Let us visulize the locations of the bramble canes being analysed.</p> <p><strong>Figure 1: Bramble Cane Locations</strong></p> <div class="row"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/bramblecanes_locations-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/bramblecanes_locations-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/bramblecanes_locations-1400.webp"></source> <img src="/assets/img/bramblecanes_locations.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" title="Bramble Cane Locations" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <p>Next, we will extimate and plot the observed K function along with the theoretical K function under CSR</p> <figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">K_hat</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">Kest</span><span class="p">(</span><span class="n">bramblecanes</span><span class="p">)</span><span class="w">
</span><span class="n">plot</span><span class="p">(</span><span class="n">K_hat</span><span class="p">,</span><span class="w"> </span><span class="n">main</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"Observed K Function vs. Theoretical K Function (CSR)"</span><span class="p">)</span></code></pre></figure> <p>Besides of the isotropic correction mentioned in Equation 4, <code class="language-plaintext highlighter-rouge">Kest</code> by defualt outputs results using the other three edge correction below:</p> <ul> <li> <p>Border correction: The border edge correction method adjusts the K function estimate by taking into account the distance between the points and the study region’s boundary. It assumes that the point pattern’s intensity is constant up to the boundary, and beyond the boundary, it drops to zero. The border method is suitable when the study region’s boundary is irregular or complex. The border method works by applying a correction factor to the K function estimates, which is based on the distance of each point to the nearest point on the boundary.</p> </li> <li> <p>Translation correction: The translate edge correction method adjusts the K function estimate by translating the point pattern to several random locations and averaging the K function estimates obtained from each translation. This method assumes that the point pattern is homogeneous and isotropic, meaning that the intensity and orientation of the point pattern are the same throughout the study region. The translate method is suitable for rectangular or square-shaped study regions with uniform boundaries.</p> </li> <li> <p>Periodic correction: The periodic edge correction method adjusts the K function estimate by creating periodic copies of the study region and the point pattern. This method assumes that the point pattern is periodic and that the study region’s shape and size repeat indefinitely in all directions. The periodic method works by creating multiple copies of the point pattern and the study region, shifting each copy by a multiple of the study region’s size, and then computing the average of the K function estimates obtained from each copy.</p> </li> </ul> <p><strong>Figure 2: Obeserved K Function vs Theoretical K function (CSR)</strong></p> <div class="row"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/bramblecanes_k_function-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/bramblecanes_k_function-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/bramblecanes_k_function-1400.webp"></source> <img src="/assets/img/bramblecanes_k_function.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" title="Bramble Cane K Functions" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <p>Finally, we can compute and plot the L function:</p> <figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">L_hat</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">Lest</span><span class="p">(</span><span class="n">bramblecanes</span><span class="p">)</span><span class="w">
</span><span class="n">plot</span><span class="p">(</span><span class="n">L_hat</span><span class="p">,</span><span class="w"> </span><span class="n">main</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"L Function: L(r) - r"</span><span class="p">)</span></code></pre></figure> <p><strong>Figure 3: Obeserved L Function vs Theoretical L function (CSR)</strong></p> <div class="row"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/bramblecanes_l_function-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/bramblecanes_l_function-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/bramblecanes_l_function-1400.webp"></source> <img src="/assets/img/bramblecanes_l_function.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" title="Bramble Cane L Functions" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <hr> <h3 id="using-g-function">Using G Function</h3> <p>The G function, also known as the nearest-neighbor distance distribution function, is defined as the cumulative distribution function of the nearest-neighbor distances between points in the point pattern.</p> <p>The equation for the G function is:</p> \[G(r) = \frac{1}{n} \sum_{i=1}^{n}\sum_{j\neq i}^{n}I(d(x_i,x_j) \leq r)\] <p>where G(r) is the value of the G function at distance r, n is the number of points in the point pattern, I() is the indicator function that takes the value 1 if the distance between the ith and jth points in the point pattern is less than or equal to r, and 0 otherwise, and $d(x_i,x_j)$ is the Euclidean distance between the ith and jth points in the point pattern.</p> <p>In other words, the G function calculates the proportion of points in the point pattern that have at least one nearest neighbor within distance r. The G function can be used to test for spatial clustering or regularity in a point pattern. If the G function values are above or below the expected values under CSR, this suggests clustering or regularity, respectively.</p> <p>We can use the envelope function to construct the upper and lower bounds of the expected values of the <code class="language-plaintext highlighter-rouge">Gest</code> function under CSR. The envelope function is calculated by repeatedly simulating CSR point patterns within the study region and calculating the G function for each simulated pattern. The envelope function is then constructed by calculating the upper and lower percentiles of the simulated G function values for each distance. The resulting upper and lower envelopes are used to compare the observed Gest function values with the expected values under CSR.</p> <figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">gf.env</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">envelope</span><span class="p">(</span><span class="n">bramblecanes</span><span class="p">,</span><span class="w"> </span><span class="n">Gest</span><span class="p">,</span><span class="w"> </span><span class="n">correction</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"border"</span><span class="p">)</span><span class="w">
</span><span class="n">plot</span><span class="p">(</span><span class="n">gf.env</span><span class="p">)</span></code></pre></figure> <p><strong>Figure 4: Obeserved G Function vs Theoretical G function with Envelope (CSR)</strong></p> <div class="row"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/bramblecanes_g_function-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/bramblecanes_g_function-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/bramblecanes_g_function-1400.webp"></source> <img src="/assets/img/bramblecanes_g_function.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" title="Bramble Cane G Functions" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <hr> <h2 id="example-of-morans-i">Example of Moran’s I</h2> <h3 id="the-pennsylvania-lung-cancer-data">The Pennsylvania Lung Cancer Data</h3> <p>The <code class="language-plaintext highlighter-rouge">spatialepi</code> package in R contains several datasets related to the spatial analysis of epidemiological data. One of these datasets is the <code class="language-plaintext highlighter-rouge">pennLC</code> dataset, which contains information on lung cancer incidence rates in Pennsylvania by county in 2002.</p> <figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="c1"># Make sure the necessary packages have been loaded </span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="n">tmap</span><span class="p">)</span><span class="w"> 
</span><span class="n">library</span><span class="p">(</span><span class="n">tmaptools</span><span class="p">)</span><span class="w"> 
</span><span class="n">library</span><span class="p">(</span><span class="n">SpatialEpi</span><span class="p">)</span><span class="w"> 
</span><span class="n">library</span><span class="p">(</span><span class="n">sf</span><span class="p">)</span><span class="w">
</span><span class="c1"># Read in the Pennsylvania lung cancer data </span><span class="w">
</span><span class="n">data</span><span class="p">(</span><span class="n">pennLC</span><span class="p">)</span><span class="w">
</span><span class="c1"># Extract the SpatialPolygon info </span><span class="w">
</span><span class="n">penn.state.latlong</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">pennLC</span><span class="o">$</span><span class="n">spatial.polygon</span><span class="w"> 
</span><span class="c1"># Convert to UTM zone 17N </span><span class="w">
</span><span class="n">penn.state.latlong</span><span class="o">&lt;-</span><span class="w"> </span><span class="n">st_as_sf</span><span class="p">(</span><span class="n">penn.state.latlong</span><span class="p">)</span><span class="w">
</span><span class="n">penn.state.utm</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">set_projection</span><span class="p">(</span><span class="n">penn.state.latlong</span><span class="p">,</span><span class="w"> </span><span class="m">3724</span><span class="p">)</span><span class="w"> 
</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="s2">"sf"</span><span class="w"> </span><span class="o">%in%</span><span class="w"> </span><span class="nf">class</span><span class="p">(</span><span class="n">penn.state.latlong</span><span class="p">))</span><span class="w"> 
</span><span class="n">penn.state.utm</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">as</span><span class="p">(</span><span class="n">penn.state.utm</span><span class="p">,</span><span class="w"> </span><span class="s2">"Spatial"</span><span class="p">)</span><span class="w"> 
</span><span class="c1"># Obtain the smoking rates </span><span class="w">
</span><span class="n">penn.state.utm</span><span class="o">$</span><span class="n">smk</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">pennLC</span><span class="o">$</span><span class="n">smoking</span><span class="o">$</span><span class="n">smoking</span><span class="o">*</span><span class="m">100</span><span class="w"> 
</span><span class="c1"># Draw a choropleth map of the smoking rates</span><span class="w">
</span><span class="n">tm_shape</span><span class="p">(</span><span class="n">penn.state.utm</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">tm_polygons</span><span class="p">(</span><span class="n">col</span><span class="o">=</span><span class="s2">"smk"</span><span class="p">,</span><span class="w"> </span><span class="n">title</span><span class="o">=</span><span class="s2">"Percent of Population"</span><span class="p">)</span></code></pre></figure> <p><strong>Figure 5: Pennsylvania Smoking Rates</strong></p> <div class="row"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/Pennsylvania_smoking_uptake-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/Pennsylvania_smoking_uptake-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/Pennsylvania_smoking_uptake-1400.webp"></source> <img src="/assets/img/Pennsylvania_smoking_uptake.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" title="Pennsyvania Smoking Rates" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="c1"># Set up a set of five 'fake' smoking update rates as well as the real one </span><span class="w">
</span><span class="c1"># Create new columns in penn.state.utm for randomised data </span><span class="w">
</span><span class="c1"># Here the seed 4676 is used. Use a different one to get an unknown outcome. </span><span class="w">
</span><span class="n">set.seed</span><span class="p">(</span><span class="m">4676</span><span class="p">)</span><span class="w">
</span><span class="n">penn.state.utm</span><span class="o">$</span><span class="n">smk_rand1</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">sample</span><span class="p">(</span><span class="n">penn.state.utm</span><span class="o">$</span><span class="n">smk</span><span class="p">)</span><span class="w"> 
</span><span class="n">penn.state.utm</span><span class="o">$</span><span class="n">smk_rand2</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">sample</span><span class="p">(</span><span class="n">penn.state.utm</span><span class="o">$</span><span class="n">smk</span><span class="p">)</span><span class="w"> 
</span><span class="n">penn.state.utm</span><span class="o">$</span><span class="n">smk_rand3</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">sample</span><span class="p">(</span><span class="n">penn.state.utm</span><span class="o">$</span><span class="n">smk</span><span class="p">)</span><span class="w"> 
</span><span class="n">penn.state.utm</span><span class="o">$</span><span class="n">smk_rand4</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">sample</span><span class="p">(</span><span class="n">penn.state.utm</span><span class="o">$</span><span class="n">smk</span><span class="p">)</span><span class="w"> 
</span><span class="n">penn.state.utm</span><span class="o">$</span><span class="n">smk_rand5</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">sample</span><span class="p">(</span><span class="n">penn.state.utm</span><span class="o">$</span><span class="n">smk</span><span class="p">)</span><span class="w"> 

</span><span class="c1"># Scramble the variables used in terms of plotting order </span><span class="w">
</span><span class="n">vars</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">sample</span><span class="p">(</span><span class="nf">c</span><span class="p">(</span><span class="s1">'smk'</span><span class="p">,</span><span class="s1">'smk_rand1'</span><span class="p">,</span><span class="s1">'smk_rand2'</span><span class="p">,</span><span class="s1">'smk_rand3'</span><span class="p">,</span><span class="s1">'smk_rand4'</span><span class="p">,</span><span class="s1">'smk_rand5'</span><span class="p">))</span><span class="w">

</span><span class="c1"># Which one will be the real data? </span><span class="w">
</span><span class="c1"># Don't look at this variable before you see the maps! </span><span class="w">
</span><span class="n">real.data.i</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">which</span><span class="p">(</span><span class="n">vars</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s1">'smk'</span><span class="p">)</span><span class="w"> 

</span><span class="c1"># Draw the scrambled map grid </span><span class="w">
</span><span class="n">tm_shape</span><span class="p">(</span><span class="n">penn.state.utm</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> 
  </span><span class="n">tm_polygons</span><span class="p">(</span><span class="n">col</span><span class="o">=</span><span class="n">vars</span><span class="p">,</span><span class="w"> </span><span class="n">legend.show</span><span class="o">=</span><span class="kc">FALSE</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> 
  </span><span class="n">tm_layout</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="w"> </span><span class="m">1</span><span class="o">:</span><span class="m">6</span><span class="p">,</span><span class="w"> </span><span class="n">title.position</span><span class="o">=</span><span class="nf">c</span><span class="p">(</span><span class="s2">"right"</span><span class="p">,</span><span class="s2">"top"</span><span class="p">))</span></code></pre></figure> <h3 id="visual-explotration-of-autocorrelation">Visual Explotration of Autocorrelation</h3> <p><strong>Figure 6: Randomized Pennsylvania Smoking Rates</strong></p> <div class="row"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/random_Pennsylvania_smoking_uptake-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/random_Pennsylvania_smoking_uptake-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/random_Pennsylvania_smoking_uptake-1400.webp"></source> <img src="/assets/img/random_Pennsylvania_smoking_uptake.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" title="Randomized Pennsyvania Smoking Rates" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <p>Moran’s I is calculated using the formula:</p> \[I = \frac{n}{\sum_{i=1}^{n}\sum_{j=1}^{n}w_{ij}} \frac{\sum_{i=1}^{n}\sum_{j=1}^{n}w_{ij}(x_i - \bar{x})(x_j - \bar{x})}{\sum_{i=1}^{n}(x_i - \bar{x})^2}\] <p>where $n$ is the number of observations, $w_{ij}$ is the spatial weight between observation $i$ and observation $j$, $x_i$ is the value of the variable of interest for observation $i$, and $\bar{x}$ is the mean value of the variable of interest.</p> <p>The first term in the formula represents the spatial scale of analysis, or the effective number of neighboring observations. It is equal to $n$ divided by the sum of the spatial weights matrix $W$, which represents the total number of neighboring observations across all observations.</p> <p>The second term in the formula represents the spatial autocovariance of the variable of interest. It is calculated as the sum of the product of the spatial weight $w_{ij}$ between each pair of observations $i$ and $j$, and the difference between the variable value $x_i$ for observation $i$ and the mean value $\bar{x}$ of the variable across all observations, and the same difference for observation $j$. This term quantifies the degree to which similar values of the variable tend to be clustered together in space.</p> <p>The third term in the formula represents the overall variance of the variable of interest. It is calculated as the sum of the squared difference between the variable value $x_i$ for each observation $i$ and the mean value $\bar{x}$ of the variable across all observations. This term represents the total amount of variation in the variable across all observations.</p> <p>To calculate the spatial weights $w_{ij}$ for Moran’s I, there are several methods available, but the most common ones include the following:</p> <ol> <li>Binary contiguity: In this method, two observations are considered neighbors if they share a common boundary or vertex in a spatial domain. The spatial weight $w_{ij}$ is set to 1 if observation $i$ and $j$ are neighbors, and 0 otherwise.</li> </ol> \[w_{ij} = \begin{cases} 1, &amp; \text{if }i,j \text{ are neighbors}\\ 0, &amp; \text{otherwise} \end{cases}\] <ol> <li>Distance-based weights: In this method, spatial weights are calculated based on the distance between observations. The spatial weight $w_{ij}$ is set to a decreasing function of the distance between observation $i$ and $j$, such that observations that are closer together have a higher weight than those that are farther apart.</li> </ol> \[w_{ij} = \frac{1}{d_{ij}^p}\] <p>where $d_{ij}$ is the Euclidean distance between observations $i$ and $j$, and $p$ is a positive constant that controls the rate of decrease of the weight with distance.</p> <ol> <li>K-nearest neighbor weights: In this method, the spatial weight $w_{ij}$ is set to 1 if observation $j$ is one of the k-nearest neighbors of observation $i$, and 0 otherwise.</li> </ol> \[w_{ij} = \begin{cases} 1, &amp; \text{if }j \text{ is one of the k-nearest neighbors of }i\\ 0, &amp; \text{otherwise} \end{cases}\] <ol> <li>Kernel weights: In this method, spatial weights are calculated based on a continuous function that assigns weights to all observations in the study area, depending on their distance from the focal observation $i$. The spatial weight $w_{ij}$ is set to the value of the kernel function evaluated at the distance between observation $i$ and $j$.</li> </ol> \[w_{ij} = K\left(\frac{d_{ij}}{h}\right)\] <p>where $K$ is the kernel function, $d_{ij}$ is the Euclidean distance between observations $i$ and $j$, and $h$ is a positive constant that controls the bandwidth of the kernel. Commonly used kernel functions include the Gaussian, uniform, and triangular kernels.</p> <ol> <li>Lagged mean weights: In this method, spatial weights are calculated based on the average value of the variable of interest for neighboring observations. The spatial weight $w_{ij}$ is set to the ratio of the deviation of the value of observation $j$ from the mean of all neighboring observations of observation $i$, divided by the variance of the variable.</li> </ol> \[w_{ij} = \frac{x_j - \bar{x}_{N_i}}{\sum_{k \in N_i}(x_k - \bar{x}_{N_i})^2}\] <p>where $x_j$ is the value of the variable for observation $j$, $\bar{x}_{N_i}$ is the mean value of the variable for all observations in the neighborhood of observation $i$ (excluding observation $i$ itself), and $N_i$ is the set of neighbors of observation $i$. This method accounts for spatial autocorrelation in the variable of interest by estimating the local variance of the variable based on neighboring observations.</p> <p>Note that the lagged mean method assumes that the relationship between neighboring observations is linear and stationary. It may not be appropriate for non-linear or non-stationary</p> <figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">require</span><span class="p">(</span><span class="n">spdep</span><span class="p">)</span><span class="w">
</span><span class="c1"># Calculate spatial weights matrix</span><span class="w">
</span><span class="n">nb</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">poly2nb</span><span class="p">(</span><span class="n">penn.state.utm</span><span class="p">,</span><span class="w"> </span><span class="n">queen</span><span class="o">=</span><span class="kc">TRUE</span><span class="p">)</span><span class="w">
</span><span class="n">W</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">nb2listw</span><span class="p">(</span><span class="n">nb</span><span class="p">)</span><span class="w">

</span><span class="c1"># Calculate Moran's I for smoking rates</span><span class="w">
</span><span class="n">moran</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">moran.test</span><span class="p">(</span><span class="n">penn.state.utm</span><span class="o">$</span><span class="n">smk</span><span class="p">,</span><span class="w"> </span><span class="n">listw</span><span class="o">=</span><span class="n">W</span><span class="p">)</span><span class="w">

</span><span class="c1"># Print Moran's I results</span><span class="w">
</span><span class="n">cat</span><span class="p">(</span><span class="s2">"Moran's I for smoking rates:"</span><span class="p">,</span><span class="w"> </span><span class="n">moran</span><span class="o">$</span><span class="n">estimate</span><span class="p">[</span><span class="m">1</span><span class="p">],</span><span class="w"> </span><span class="s2">"\n"</span><span class="p">)</span><span class="w">
</span><span class="n">cat</span><span class="p">(</span><span class="s2">"p-value:"</span><span class="p">,</span><span class="w"> </span><span class="n">moran</span><span class="o">$</span><span class="n">p.value</span><span class="p">,</span><span class="w"> </span><span class="s2">"\n"</span><span class="p">)</span></code></pre></figure> </d-article> <d-appendix> <d-footnote-list></d-footnote-list> <d-citation-list></d-citation-list> </d-appendix> <d-bibliography src="/assets/bibliography/2018-12-22-distill.bib"></d-bibliography><div id="giscus_thread" style="max-width: 800px; margin: 0 auto;"> <script>let giscusTheme=localStorage.getItem("theme"),giscusAttributes={src:"https://giscus.app/client.js","data-repo":"Kenan-Li/personal_website_kl","data-repo-id":"MDEwOlJlcG9zaXRvcnk2MDAyNDM2NQ==","data-category":"Comments","data-category-id":"DIC_kwDOA5PmLc4CTBt6","data-mapping":"title","data-strict":"1","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":giscusTheme,"data-lang":"en",crossorigin:"anonymous",async:""},giscusScript=document.createElement("script");Object.entries(giscusAttributes).forEach(([t,e])=>giscusScript.setAttribute(t,e)),document.getElementById("giscus_thread").appendChild(giscusScript);</script> <noscript>Please enable JavaScript to view the <a href="http://giscus.app/?ref_noscript" rel="external nofollow noopener" target="_blank">comments powered by giscus.</a> </noscript> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2023 Kenan Li. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>